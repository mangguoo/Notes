## Docker是什么

> Docker 是一种容器化技术工具，用于将应用程序及其运行所需的环境打包在一起。通过 Docker，我们可以把代码、运行时、系统工具和库等打包成一个容器镜像，然后在任何安装了 Docker 的机器上运行该容器，从而确保环境一致，避免"在我机器上能跑"的环境差异问题。简单来说，Docker 提供了一个隔离的运行环境，让应用在不同的环境下都能够以相同的方式运行。

### Docker的主要优势

- **轻量便携**：Docker 容器相比虚拟机更加轻量，不需要嵌入完整操作系统，只包含应用所需的文件，启动和停止非常快速。
- **一致性**：开发者可以在开发环境打包应用及依赖，运维直接在服务器上运行相同的容器镜像，避免因为环境配置不同导致的问题。
- **隔离性**：每个容器都有独立的文件系统和运行时环境，彼此隔离，确保安全和稳定，同时又能高效地在同一个主机上运行多个容器。

## Docker 为什么能"无视操作系统"？

> Docker 经常被认为可以"无视"操作系统差异，这是因为容器共享宿主机的内核，只携带用户空间环境：

### 共享宿主机内核

容器并不是完整的操作系统，它不包含自己的内核。所有 Docker 容器实际上使用的都是宿主机操作系统的内核。Docker 从不使用与宿主机不同的内核——这意味着 Linux 容器需要 Linux 内核，Windows 容器需要 Windows 内核。容器内部的系统调用由宿主内核处理，因此容器依赖于宿主的内核能力。

### 镜像提供用户空间

Docker 镜像通常包含某种操作系统发行版的用户空间部分（例如 Ubuntu 的二进制和库，或 Alpine 等），提供运行所需的工具和库，但不包含内核。容器启动时，会将镜像提供的用户空间挂载为容器的根文件系统，但底层用的是宿主内核。也就是说，Docker 镜像决定了容器的用户态环境，而内核态依然由宿主系统提供。

### 内核兼容性要求

由于以上原因，只要宿主机内核能够支持容器内所需的系统调用和功能，容器就可以正常运行；否则就会出现不兼容。例如，在 Linux 主机上可以运行不同发行版的 Linux 容器（Debian、CentOS 等）因为它们都使用 Linux 内核接口，但不能直接运行 Windows 容器，因为 Windows 容器需要 Windows 内核支持。

简而言之，Docker 没有魔法地忽略操作系统，而是利用宿主操作系统内核来运行容器。它能做到"跨发行版"主要是因为不同 Linux 发行版间仍共享 Linux 内核接口，但不能跨不同内核种类。正如一句话所说："**容器使用的永远是宿主机的内核**"。

## Docker 镜像的分层机制

Docker 镜像采用了分层存储设计，类似于 Git 的多层快照，每一层代表了一次文件系统改动。这种机制带来了高效的存储复用和快速的镜像构建。

### 镜像分层构建

通常我们使用 Dockerfile 构建镜像。Dockerfile 中的每一条指令（比如 `FROM`、`RUN`、`COPY` 等）都会生成镜像的一个新层。最终镜像是由多层叠加组成的。这种分层结构使得镜像可以重用之前构建的层，而无需每次都从头开始构建所有内容。

### 只读层和可写层

镜像构建产生的各层都是只读的，包含了基础操作系统、应用程序以及依赖等内容。当我们启动一个容器时，Docker 会在镜像的只读层之上再添加一层 **可写层（Writable Layer）** 作为容器运行时的最上层。容器对文件系统的所有修改（新增/修改文件等）都会写入这一可写层，而下方的镜像只读层不会被直接改动。

### 写时复制（Copy-On-Write）

Docker 使用写时复制机制来优化文件操作。当容器需要修改来自下层只读镜像的一个文件时，并不会直接修改底层文件；相反，Docker 会先将该文件从只读层复制一份到容器的可写层，然后在副本上应用修改。这样一来，其他容器仍然可以共享未修改的镜像层文件，而不会相互影响。这种按需复制的策略最大程度提高了存储效率：容器运行时无需拷贝镜像的所有数据，只有在第一次写入时才复制需要修改的文件。

### 存储与构建效率

分层镜像设计带来了多方面的效率提升。例如，如果多个镜像基于同一个底层（如都来自相同的基础镜像），那么主机上只需要存储一份该基础层，所有镜像和容器都共享这一层，大大节省存储空间。同时，构建镜像时如果某一层没有变化，Docker 可以直接利用缓存的该层，而不必重新构建，显著加快镜像构建和分发速度。

### 示例说明

假设我们有两个基于 `python:3.9` 基础镜像构建的应用镜像，它们都会包含相同的 Python 运行时层。得益于分层机制，主机只需存储一份 Python 层即可被两个镜像共享。运行容器时，每个容器有自己独立的可写层用于存放修改，但都共同依赖只读的 Python 基础层。这样既节省了磁盘，又加快了容器启动和镜像拉取的速度。

## 容器运行时发生了什么？

当我们执行 `docker run` 启动一个容器时，Docker 在后台结合操作系统内核完成一系列工作来创建隔离的容器进程。主要步骤包括：

### 1. 准备文件系统

Docker 根据指定的镜像构建容器的根文件系统。它会将镜像的各个只读层利用联合文件系统（如 OverlayFS）叠加起来，并挂载一个新的可写容器层在顶部，作为容器独立的文件系统视图。简而言之，此步骤完成容器所见的"硬盘"准备，其中包含了镜像内的所有文件，加上一个空的可写层用于容器运行时的临时改动。

### 2. 设置 Namespace 隔离

Docker 利用 Linux 内核的**命名空间（Namespaces）**功能为容器创建隔离的运行环境，主要包括：

- **进程隔离**：创建新的进程命名空间（PID Namespace），容器内的进程彼此可见，但无法看到宿主机上其他不相关的进程。容器中的第一个进程PID从1开始，就像一个独立系统的 init 进程。
- **文件系统隔离**：利用挂载命名空间（Mount Namespace），容器只能看到并访问前面准备的容器文件系统（镜像层+可写层），与宿主的文件系统隔离。
- **网络隔离**：创建网络命名空间（Network Namespace），给予容器自己独立的网络堆栈。容器可以有自己的虚拟网卡、IP 地址等，通常Docker还会连接容器到一个虚拟桥接网络，实现容器与宿主及其他容器的通信隔离。
- **用户隔离（可选）**：在需要时，Docker 还能为容器启用用户命名空间，使容器内部的用户和宿主用户相互映射隔离，从而增强安全性。

### 3. 应用 Cgroups 限制

Docker 使用 Linux 的 **控制组（cgroups）** 机制对容器实施资源配额和限制。通过 cgroups，Docker 可以限制容器使用的 CPU、内存、IO 等资源，防止某个容器过度占用资源影响宿主或其他容器。这保证了多容器环境下的性能稳定，也为每个容器提供了一个受控的资源"沙箱"。

### 4. 启动容器进程

完成以上文件系统和隔离设置后，Docker 调用底层的容器运行时（例如 runc），在容器环境中启动指定的应用进程。这个进程就是容器的主进程（PID 为 1），它在隔离的环境里开始执行镜像定义的指令（例如运行 `/bin/sh` 或应用程序）。从外部看，这个进程类似于在一个独立的系统中运行，但实际上它只是宿主机上受隔离限制的一个普通进程。当该进程终止时，容器也随之退出，Docker 清理相关的资源（如释放文件系统挂载、cgroup 配额等）。

> 以上过程使得容器与宿主系统以及其他容器实现了良好的隔离：每个容器就好比在独立运行，但开销比完整虚拟机要小得多。本质上，容器只是运行在宿主机上的一个进程，只不过通过内核提供的隔离机制，看起来拥有了独立的环境。

## 容器是否可以指定运行的操作系统？

容器并不能任意指定或更换内核操作系统环境。具体来说：

### 只能指定用户空间类型

在启动容器时，我们可以选择不同的镜像，例如基于 Ubuntu、Alpine 或 Windows 的镜像等。这决定了容器的用户态环境（例如使用 Ubuntu 的发行版工具链或 Windows 的运行时库）。但是，这并不改变容器所使用的内核类型。容器始终使用宿主机提供的内核，而无法通过选择镜像来更换内核。也就是说，如果宿主机是 Linux 内核，则容器无论基于何种 Linux 发行版镜像，底层用的都是该 Linux 内核；你无法在 Linux 主机上直接运行出一个 Windows 内核来。

### 跨平台需要虚拟化支持

由于上述原因，Linux 容器只能在 Linux 内核上运行，Windows 容器只能在 Windows 内核上运行，二者不能直接混用。然而，我们常听说可以在非 Linux 系统上运行"Linux 容器"，这是因为 Docker 做了一些底层处理：

在 Windows 或 macOS 上运行 Linux 容器时，Docker 会借助虚拟化技术提供一个微型的 Linux 内核环境：

- **Windows 系统**：在 Windows 10+ 上，Docker 利用 WSL2（Windows Subsystem for Linux 2）或者 Hyper-V 虚拟机来启动一个精简的 Linux 内核，这样容器实际上还是跑在这个 Linux 内核之上（只是对用户透明，看起来像直接在 Windows 上运行）
- **macOS 系统**：在 macOS 上，Docker 会在后台启用一个轻量级的Linux虚拟机（以前是通过 HyperKit，如今通过 Apple Hypervisor 或 QEMU 等）来承载 Linux 容器

所以，当我们"指定"一个不同操作系统的容器时，实际上 Docker 在非原生环境下隐藏地切换了执行内核（通过虚拟化），并非容器自身突破了内核限制。

### Windows 容器与 Linux 容器

值得注意的是，Docker 桌面版在 Windows 上可以同时运行 Windows 容器和 Linux 容器，但不能混用：

- **Windows 容器**：直接使用 Windows 宿主的内核做隔离（需要启用 Windows 容器模式）
- **Linux 容器**：使用 WSL2/虚拟机提供的 Linux 内核

在 Linux 主机上则原生只能运行 Linux 容器；如果一定要运行 Windows 容器，必须在 Linux 上启动一个 Windows 虚拟机来提供 Windows 内核环境，复杂且少有这样的需求。

> **总结**：容器的"操作系统"主要指用户空间部分，可以通过不同镜像来更换用户态环境；但容器无法自行更换底层内核，跨不同内核体系的容器运行需要借助额外的虚拟化手段。

## 跨操作系统不兼容的示例

不同操作系统内核接口和环境的差异，决定了容器不能跨内核直接运行。以下是几个实际例子说明这种不兼容性：

### 系统调用差异

Linux 和 Windows 在创建进程等底层操作上截然不同：

- **Linux**：程序通常使用 `fork()` 系统调用创建新进程
- **Windows**：没有直接等价的 `fork()`，Windows 程序通过 Windows API（如 `CreateProcess()`）来启动进程

倘若一个应用在容器中调用了 Linux 特有的系统调用，那么在 Windows 内核上将无法识别执行；反之亦然。因此，一个编译为 Linux 的程序无法在 Windows 内核环境下运行，就是因为所需的系统调用接口不存在或不兼容。

### 文件路径和文件系统结构

操作系统之间的文件路径表示和结构也不同：

- **Linux**：使用 `/` 作为根目录，路径以正斜杠分隔，如 `/usr/bin/python`
- **Windows**：使用盘符和反斜杠，如 `C:\Windows\System32\cmd.exe`

如果容器内的应用假设了某种路径存在（比如访问 `/etc/passwd` 等配置文件）但宿主操作系统并没有对应的路径结构，那么跨平台运行就会失败。此外，Linux 和 Windows 的文件系统特性也不同，比如大小写敏感与否、权限模型差异等，这些都会导致应用无法直接在另一种内核上正常工作。

### 二进制格式和动态库

Linux 与 Windows 的可执行文件格式和动态链接机制完全不一样：

- **Linux**：使用 ELF 格式可执行文件，依赖 `.so`（共享对象）动态链接库（例如 GNU C库 `libc.so`）
- **Windows**：使用 PE 格式可执行文件，依赖 `.dll` 动态链接库和 Windows API 子系统

一个 Linux 下编译的程序在 Windows 上无法运行，不仅因为系统调用不同，还因为 Windows 根本无法加载 ELF 格式的可执行文件和其依赖的 `.so` 库（除非通过类似 Wine 这样的兼容层）。同样地，Windows 可执行文件也无法在 Linux 内核上运行。容器并不模拟 CPU 或操作系统层的这些差异，所以跨OS的镜像不可直接运行。

### 其他环境差异

还有很多细节差别，比如进程调度、线程模型、设备接口名、系统配置文件位置等都因操作系统而异。一个典型例子是：

- 在 Linux 容器内尝试使用 Linux 的 `/dev` 设备或 `/proc` 接口获取系统信息，这在 Windows 内核上是不存在的
- Windows 容器中的应用可能调用 Windows 注册表或特定服务，这在 Linux 上也无从提供

这些实际差异都会造成跨OS运行的不兼容。

## 总结

总而言之，Docker 并不能让不兼容的程序在错误的平台上运行。容器需要匹配宿主机的内核接口才能发挥作用，这也是为什么我们在使用 Docker 时必须选择合适的镜像与宿主环境搭配：

- 要运行 **Linux 应用** 请选择 Linux 镜像并在 Linux 内核环境下运行
- 要运行 **Windows 应用** 则需要 Windows 容器镜像并在 Windows 主机（或相应VM）下运行

> Docker 提供了一定程度的灵活性和移植性，但并不绕过操作系统本身的兼容性限制。
