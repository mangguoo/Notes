# 比特链

> 区块链的实质就是一个账本，但是与传统的中心化帐本不同，它不是存储在一个中心服务器中，而是存储在一些想要记帐的用户手上(记帐可以得到奖励，挖矿)，这些用户都会把在区块链上发生的交易记录下来，并将他们进行加密(但是要完成一定的工作量)，只要有一个用户成功计算一个块，就会向其它记帐的用户广播，但是这里广播并不通过一个中心服务器，而是点对点通信。这样就能保证区块链这个帐本是不可篡改的

## **账本隐私和快速对账**

> 比特币系统是通过密码学中的**Hash算法（哈希值）**来解决个人隐私和快速对账2个问题
>
> 这是举一个例子，张三要用1BTC买李四一头牛，这时他俩就把这个交易信息广播出去，记帐的人们(矿工)收到之后就会开始记帐(加密)，记得最快的那个当然就会获得奖励

- 对交易信息进行加密，提取实物的特征。比如使用公钥来代表用户身份，公钥是根据密钥来进行推算的，并且无法反推
- 通过比对hash值是否一致，就可以知道账本是否一致(对账)：如果前面交易信息不同，就会导致**hash值(哈希值)**不一致

## **账本一致性/共识机制：**

> **双花问题**（同样一笔数字资产被重复支付，即同样一笔钱被花掉两次或多次）
>
> 接上面那个例子，张三用1BTC买了李四一头牛后，记帐的人们把这笔交易记录到了帐本之中，而这时张三起了坏心思，找到了还不知道这个消息的王五，说要用1BTC买它一只牛，但是其实他这个BTC已经花出去了，由于链上记帐的人们已经记录了它与李四的交易，所以他只能自己伪造了一个新的帐本，这个帐本上记录他与王五的交易
>
> 这就意味着链上的其它人的帐本与张三的帐本是不同的，比特币链发生了分叉，张三想要让自己的帐本获得认可，就必须依靠比特币链上的最长链为可信任链条的机制，也就是说，张三必须比区块链上所有记帐的人更快的算出接下来的区块，并且广播得到其他人的认可才行，这样想要达成这个目的需要超过全网51%的算力，这自然是不可能的

### 解决双花问题：

1. **最长链为可信任的链条来保持一致性**

比特币记录交易的原理，就是系统内的计算机开始比赛，争取又快又准的算出这倒题目，比拼的是计算机算力。胜出的计算机将拥有记账权成为矿工，矿工取得一定奖励（12.5比特币）。胜出的计算机将交易信息打造成新的区块，并将新的区块信息广播出去，使链增长。每一个计算机都是分布式账本的结点

如果有人伪造账本，那么他需要成为之后拥有记账权的那个人、才能创造新的区块、并拉长另外一条分叉的链条，让他自己伪造的链条成为最长的链条。但分叉的那条链是由伪造者一个人去维护的，是拼不过全网中所有矿工一起创造的主链

2. **用POW获取记账权来保证账本的一致性**

> 工作量证明（Proof of Work, POW）
>
> - Nance: 会一直试的计算次数
>
> - 寻找小于系统给定的目标值的Hash值：这个值会根据全网的算力变化而动态调整
>
> - 最后找到符合条件的Hash值和Nance，所以算力越强的电脑，更容易拿到记账权，从而增加区块，拉长链条
>
> - POW是人为设计的一种运算方式，伪造账本只有在长时间保持算力优先才有可能伪造账本，但这几乎不可能

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230129174505116.png" alt="image-20230129174505116" style="zoom: 67%;" />



## **比特币的分叉**

比特币系统协议层面出现了分歧

- 硬分叉（不可合并）：系统更新产生硬分叉，如比特币区块的扩容：旧比特币单秒交易笔数7笔（1MB对应的字节），但如果不同矿工使用不同版本的比特币系统进行挖矿，一些区块扩容而一些没有，旧矿工无法接受扩容后的区块，就形成分叉

  在旧区块链中，一个区块的大小是1MB，而单笔交易的大小为250b，这就导致一个区块只能存储4194笔交易。而在比特链中，平均产生一个区块的时间为10分钟，也就是600s，这也就限定了比特链的单秒交易量为4194/600=7笔。而如果想要增加比特链的单秒交易量，最好的办法就是增加区块的容量（新的区块大小变为了8M，可以容纳每秒56笔交易）

  而如果想要增加区块容量，显然就得升级挖矿软件，这时就有可能造成分歧，因为有的矿工可能会不认同新的规则，因此他们就继续使用旧的软件进行挖矿，就会造成如下结果：

  <img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230129180547344.png" alt="image-20230129180547344" style="zoom: 33%;" />

- 软分叉（可合并）：如果短暂出现但最后可以合并回主链(一般出现在两个人同时计算出一个区块或者有人想要篡改数据)

## **总结**

- 比特币不是一种货币，而是一种分布式账务系统。账本在每个参与者的电脑上备份，并且实时同步和对账；账本记录了一定数量的比特币交易的过程，每次记录下的交易过程和结果都会广播到网络，让所有节点都保持一致

- 比特币系统采用了去中心化的方式。不是没有中心, 而是中心不停变化，每一次中心由节点竞争而得出记账权，记录交易打造成新的区块（每一笔交易中挖矿成功的矿工就是中心）

- 区块链1.0技术（所有比特币中应用到的技术）：分布式数据存储，点对点传输，共识机制（POW），加密算法

# **以太坊**

> 以太坊是运行在一个计算机网络中的软件，它确保数据以及智能合约的小程序可以在没有中心协调者的情况下，被所有网络中的计算机复制和处理。以太坊的愿景是创建一个无法停止，抗屏蔽(审查)和自我维持的去中心化世界计算机
>
> **比特币的不足**
>
> - POW算法出块速度慢（10分钟）
> - 比特币矿场消耗大量电能
> - 仅完成了货币的去中心化
>
> **以太坊的改进(V神发明)**
>
> - 出块速度提升(15秒)：以太坊区块链中将出块时间从10分钟提升到15秒
> - 修改挖矿机制：POW+POS(权益证明)算法，逐步向POS算法过渡
> - 智能合约：合同的去中心化，不仅限于货币的去中心化。公开透明无黑幕，违反规则，直接扣除保证金，不可停止

在以太坊中的所有节点都可以发布智能合约，这些合约发布者，一般会将合约代码开源，由用户来检查，如果用户觉得没有问题，就可以去使用

比如说用户A发布了一个福利彩票的合约，他将合约代码开源之后，想要使用这个合约的用户觉得他的代码没有逻辑错误，保证了公平性，那他就可以去买用户A的彩票，用户A就可以从中获利

## **以太坊平台专业词汇**

- MetaMask插件：第三方的虚拟钱包，方便买卖

- 账户地址：付款或收款的地址，类似银行卡号

- 以太币：基于以太坊的虚拟货币

- 手续费gas(nickname：油费): 查看智能合约不需要支付手续费，但是修改智能合约需要支付，付的手续费是以太币

  这样其实是为了屏蔽恶意攻击，要支付手续费(油费)的多少是根据网络拥堵情况决定的

  - gas price：油单价(cwei)
  - gas limit：油数量，这个值是自己定义的，如果油费给的超出了，以太坊会退回，但是如果给的不够，不仅写入数据会失败，并且gas也不会退回
  - 计算公式：gas price x gas limit

## **智能合约**

> 跑在以太坊系统中的代码合同，本质是一串代码。目前已经存在180w智能合约。它就像是公示出来的法律合同，违反它的人将遭到处罚

- 智能合约适合表达规则明确且不轻易修改，不受人为主观因素影响的业务
- 如果业务的规则经常变化，那么他就不适合使用智能合约去表达，因为智能合约一旦上链，是无法进行更改的

## Ghost协议

> Ghost协议是解决Centralization Bias：尽快招安分叉区块/分支链的尽快合并，以促成统一的区块链

由于以太坊中每15秒就会出一个新块，这就会大大增加同时有多个矿工挖出一个区块的可能，因为区块产生时间太短，当有一个节点打包完成一个区块进行广播之后，开始运算下一个区块时，可能会接到多个节点计算出相同区块的广播，这时肯定谁都不愿易合并到别人的链上，因此就会形成大量分叉

而在网络中占据较大算力的矿池其算力巨大，而且通常地理位置优越，其网络与更多的节点相连，它发布的区块能跟更快的在网络中传播，因此在出现区块链分叉时，其所在的分叉更有可能成为主链。这种情况下，其他算力较低的矿池或者个体节点就不能得到出块奖励，在以太坊中经常发生区块链分叉的情况，但最后区块链的出块奖励大部分情况下都被大型矿池拿走，而算力小的节点通常很少拿到奖励，这种情况叫做“Centralization Bias”

如果以太坊沿用比特币中的出块奖励方式，算力较小的矿池几乎拿不到出块奖励，这个看起来不太公平，长此以往，算力小的矿工挖出区块之后就不愿意合并到算力强的矿工挖出的区块链中，因为合并就意味着前面的劳动全部白费了，还不如不要合并，继续在自己挖出的区块上继续挖矿，说不定运气好能超过算力强的区块呢。很明显，这样下去不利于区块链出现分叉后快速合并，会影响到区块链的共识，基于上述原因，以太坊的设计中引入了Ghost协议：

以太坊ghost协议规定每个区块最多包含2个对叔父区块的奖励，以招安分支链的区块，以太坊会给在每次主链矿工的下一代新区块产生时，分出2份奖励来招安，奖励2份7/8的出块奖励(每次出块奖励是3个以太币)，叔父链上矿工就也可以获取奖励，不会白白工作。同时，招安的主链上的区块，也可以得到2*(1/32)的出块奖励(也是为了激励矿工去招安别人)

这样就算有一台算力异常强大的矿机，每次都能抢先打包新的区块，但由于它可以在新的区块中对两个uncle区块进行奖励，这样新区块一广播，uncle区块看到有对自己的奖励，就会立即停掉运算，检查新块的合法性，只要合法，就会立刻合并到该链上去

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230129194443433.png" alt="image-20230129194443433" style="zoom:80%;" />

每隔一代，区块奖励就会减少：最近的一代uncle区块，可以得到7/8的出块奖励作为招安；再隔远一层的uncle区块，则是6/8的出块奖励作为招安；间隔8代及以后的uncle区块，则不会得到任何出块奖励。uncle区块的后续分支链上不会得到任何奖励，以激励其尽快进行合并

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230129200604518.png" alt="image-20230129200604518" style="zoom: 33%;" />

## **以太坊挖矿算法**

> 以太坊采用的是**POS（Proof of Stake，权益证明）算法**，这种挖矿方式叫虚拟挖矿（virtual mining），这种算法中每一个区块的产出要比拼矿工愿意付出出的保证金，付出的保证金越多，它挖出下一个区块的难度值就越低，这样自然也就更容易胜出。而且这部分保证金会在挖出当前区块后被冻结，直到过去n多区块之后才能被重新启用

A和B在竞争第2000个区块的时候分别付出了60和10个货币作为保证金，这样A自然就更容易胜出，而在下一个区块的竞争中，A的60个货币被冻结，自然其就只剩下40个货币，而B只有10个货币被冻结，其还剩下60个货币，这里B的货币已经比A多了，只要它愿意付出更多的货币作为保证金，那么在下一个区块的竞争中，他就更容易胜出

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130102952689.png" alt="image-20230130102952689" style="zoom: 33%;" />

目前以太坊用的是Casper协议，将POW算法和POS算法混合使用：

- POW算法来进行挖矿得出区块
- POS算法进行校验：
  - 引入了校验者Validator，投票选举区块是否可以成为主链上的区块
  - 校验者必须投入一定数量的以太币作为保证金，投入保证金的多少决定了投票的权重
  - 成为校验者，不投票不作为，或者在区块分叉的时候两边下注被举报后，都会被没收保证金
  - 每个校验者都有任期，任期结束后也有等待期，可能被检举
  - 等待期后，下注正确的校验者可以收回原来的保证金和校验收益

在下面这个例子中，以太链产生了分叉，要决定哪边可以成为主链，这个时候就需要校验者们进行投票，票数多的那条链可以成为主链

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130105724140.png" alt="image-20230130105724140" style="zoom:67%;" />

而当一些验证者不投票，或者两边投票的时候，如果被人举报，那么他们将会被扣除保证金

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130110032225.png" alt="image-20230130110032225" style="zoom:67%;" />

> 总结起来Casper协议就是通过POW算法来进行计算区块，这个算法导致的区块链分叉不再使用最长链为可信任链的机制，而是通过POS算法来竞争校验者，让校验者来投票决定哪条链成为主链

**POS算法和POW算法比较**

- POS算法省掉挖矿过程，减少大量能源损耗
- POS算法通过闭环维护系统安全
  - POW算法可以通过砸钱买算力支配，转化为对比特币系统的攻击能力，也就是说想要攻击比特币网络必须砸钱买矿机，获得全网51%以上的算力
  - POS算法，则有点类似于股东制公司，我先要成为成为公司的大股东，才能攻击这个公司。这个方法明显高明很多，比如说我想攻击以太坊链，我就必须大额购进以太币，至少要拥有超过51%以上的以太币，这样就会导致以太币大额升值，而这时我既然已经拥有了51%以上的以太币，那么为什么要搞垮他呢，对我没有任何好处

## **以太坊的分叉**

> 软分叉：分支链和主链有合并可能的分叉
>
> 硬分叉：分支链和主链无法合并
>
> - 比特币因为扩容
> - 以太坊因为黑客攻击

**The Dao智能合约**：

- 是一个众筹的项目，可以投资某个公司的项目成为投资人，可以获得分红
- 这是最民主的投资，每次投资金额的支出，都需要所有投资人同意才能执行
- The Dao智能合约允许成员成立子基金，如果要成立子基金，合同规定有28天资金锁定时间，即在这段时间中子基金中的钱是冻结的

**黑客攻击case study：**

黑客通过bug从其成立的子基金中转账盗取5000w美金到黑客子基金：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130112002764.png" alt="image-20230130112002764" style="zoom:80%;" />

> 以太坊平台开发团队内部进行了讨论，最后决定要就这次错误进行干预

- **方案一：暴力分叉**

  约定好黑客攻击的链是不合法的，从分叉链开始挖，但问题是影响到后续区块的合法性

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130112404870.png" alt="image-20230130112404870" style="zoom:67%;" />

- **方案二：堵住漏洞，锁定黑客帐户，退出盗取的钱**

  通过发布升级的平台，让区块不包含the Dao地址的交易（区块中包含the DAO的交易，就认为是非法区块）。新矿工（升级了平台）挖出的区块不包含the Dao地址的交易，而能接在新矿工后面的老矿工是认可上一个区块的，所以也不包含the Dao交易。但当时出了一个bug，因为认为所有和the Dao的交易是非法交易，以太坊决定非法交易不收取gas费用，而就是这个决定，在以太坊软件更新之后出现了大量非法交易，导致以太坊瘫痪，矿工没办法挖矿，无奈下矿工们就又把以太坊软件退回了以前的版本

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130113632408.png" alt="image-20230130113632408" style="zoom:67%;" />

- **方案三：硬分叉策略**

  再一次发布软件升级，这次更新把之前the Dao智能合约中的所有资金强制转移到了一个新的智能合约中(不需要经过任何人的同意)，这个智能就是一个退款合约，他规定只要挖到了第192w个区块的时候，这个退款智能合约就会把所有的钱全部如数退回至之前投资the Dao的用户的帐上

  <img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130114821210.png" alt="image-20230130114821210" style="zoom: 70%;" />

  因此，所有更新了软件升级的新矿工是有资格跟在第192w个区块之后的（相当于是erase掉黑客交易），这条主链是ETH。但没有更新软件的矿工，其合约不同意第192w个区块进行的转账，所以是无法接在这个非法的第192w个区块后的，因此会在第192w个区块前一个接口发生分叉，叫ETC classic。因此ETH和ETC产生了永久的分叉

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130114932974.png" alt="image-20230130114932974" style="zoom: 70%;" />

## ether计量单位

| 单位               | wei值   |
| ------------------ | ------- |
| wei                | 1wei    |
| Kwei(babbage)      | 1e3wei  |
| Mwei(lovelace)     | 1e6wei  |
| Gwei(shannon)      | 1e9wei  |
| microether(szabo)  | 1e12wei |
| milliether(finney) | 1e15wei |
| ether              | 1e18wei |

在区块链中，以太坊的单位是wei，并不是ether，这是因为大多编程语言都没有办法很好的运算浮点数，会导致偏差，因此在以太坊中就直接使用它的最小单位，这样所有的交易都是以整型进行运算

在javascript中，表示较大的整型时也是有可能发生错误的，因此web3.js依赖了BigNumber Lisbrary，并且会自动引入，这样就保证了大整数的运算不会出错：

```js
var balance = new BigNumber('1312423445465465465465456465465465465464')
balance.plus(21).toString(10)
```

但是如果有20位以上的浮点值，仍会导致出错。所以以太坊推荐帐户余额以wei为单位，仅向用户展示时才转换为其它单位

## **以太坊总结**

1. 缩短出块时间
2. Ghost协议：本质是重金收买分支的策略，防止centralizationi bias
3. Casper协议：POS和POW协议的混合体，让校验者保证金的额占比，换算成票数，然后投票选举
4. 增加智能合约

# 以太坊架构与组成

> 以太坊的整体架构为三层：底层服务、核心层、顶层应用，如图：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e2225ec8335~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom:67%;" />

## 区块

> 所谓的区块，其实可以定义为记录一段时间内发生的交易和状态结果的数据结构，是对当前账本状态的一次共识。区块主要由区块头、交易列表和叔区块头三部分组成：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e2225d137d0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom: 67%;" />

### **区块头**

区块头包含：父块的散列值(Prev Hash)、叔区块的散列值(Uncles Hash)、状态树根散列值(stateRoot)、交易树根散列值(Transaction Root)、收据树根散列值(Receipt Root)、时间戳(Times tamp)、随机数(Nonce)等

以太坊区块链上区块数据结构相对比特币的一个重大改变就是保存了三棵Merkle树根，分别是状态树、交易树和收据树

### **交易列表**

交易列表是由矿工从交易池中选择收入区块中的一系列交易

### **叔区块**

不在主链上的且被主链上的区块通过Uncles 字段收留进区块链的孤块叫做“叔区块” 

## 账户

> 账户以地址为索引，地址由公钥衍生而来(取公钥的最后20字节)
>
> 在以太坊系统中存在两种类型的账户:
>
> - 外部账户
> - 合约账户

### 外部账户

外部账户(Externally Owned Account, EOA)由私钥来控制，是由用户实际控制的账户，存储以太币余额状态

### 合约账户

合约账户是一个包含合约代码的账户。合约账户不是由私钥文件直接控制，而是由合约代码控制。合约账户的地址是由合约创建时合约创建者的地址，以及该地址发出的交易共同计算得出的。与外部账户相比，合约账户除了余额还有智能合约及其变量的状态

### 私钥和公钥

以太坊中每个外部账户都有一对密匙定义，即一个私钥和一个公钥。目前常见的私钥有三种形态：

1. **Private key** 

Private key就是一份随机生成的256位二进制数字。用户甚至可以用纸笔来随机地生成一个私钥，即随机写下一串256位的仅包含“0”或“1”的字符串。该256位二进制数字就是私钥最初始的状态

2. **Keystore & Password**

而在以太坊官方钱包中，私钥和公钥将会以加密的方式保存一份JSON文件，存储在Keys store子目录下。这份JSON文件就是Keys store，所以用户需要同时备份Keys store和对应的Password(创建钱包时设置的密码)

3. **Memonic code(助记词)** 

Memonic code的目的是随机生成12～24个比较容易记住的单词，该单词序列通过PBKDF2与HMAC-SHA512函数创建出随机种子，该种子可以通过BIP-0032提案的方式生成确定性钱包私钥

## 数据结构与存储

> 区块、交易等数据最终都是存储在Level DB数据库中。Level DB数据库是一个键值对(key-value)数据库，key一般与散列相关，value则是存储内容的RLP编码
>
> LevelDB是Google实现的一个非常高效的键值对数据库，其中键值都是二进制的，目前能够支持十亿级别的数据量，在这个数据量下还有着非常高的性能。以太坊中共有三个LevelDB数据库，分别是BlockDB、StateDB和ExtrasDB。BlockDB保存了块的主体内容，包括块头和交易；StateDB保存了账户的状态数据；ExtrasDB保存了收据信息和其他辅助信息
>
> 以太坊使用了MPT树(Merkle Patricia Trie)作为数据组织形式，用来组织管理用户的账户状态、交易信息等重要数据。MPT是一种加密认证的数据结构，它融合了Merkle树和Trie树(前缀树)两种数据类型的优点

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/fjkdsjfkl;adsfjkasld;fjkadslfjsdkl;fjklsdfja;sdf.png" alt="fjkdsjfkl;adsfjkasld;fjkadslfjsdkl;fjklsdfja;sdf" style="zoom:67%;" />

### 状态树

状态树包含一个键值映射，其中键是账户地址，值是账户内容，主要是｛ nonce, balance,codeHash, storageRoot ｝。nonce是账户交易的序数，balance是账户余额，codeHash是代码的散列值，storageRoot是另一棵树的根节点。状态树代表访问区块后的整个状态。以太坊是一个以账户为基础的区块链应用平台，账户的状态不是直接存储在每个区块中，所有的账户状态都是以“状态数据”的形式存储在以太坊的节点中

### 交易树

每个区块都有一棵独立的交易树。区块中交易的顺序主要由“矿工”决定，在这个块被挖出前这些数据都是未知的。不过“矿工”一般会根据交易的GasPrice和nonce对交易进行排序。首先会将交易列表中的交易划分到各个发送账户，每个账户的交易根据这些交易的nonce来排序。每个账户的交易排序完成后，再通过比较每个账户的第一条交易，选出最高价格的交易，这些是通过一个堆(heap)来实现的。在交易树包含的键值对中，其中每个键是交易的编号，值是交易内容

### 收据树

每个区块都有自己的收据树，收据树不需要更新，收据树代表每笔交易相应的收据。交易的收据是一个RLP编码的数据结构:[medstate, Gas_ used, logbloom, logs]。其中，medstate是交易处理后树根的状态；Gas_used是交易处理后Gas的使用量；logs是表格[address, [topicl, topic2 ,…], data]元素的列表，表格由交易执行期间调用的操作码LOGO …LOG4生成(包含主调用和子调用)， address是生成日志的合约地址，topicn是最多4个32字节的值，data是任意字节大小的数组；logbloom是交易中所有logs的address和topic组成的布隆过滤器

## 共识机制

> 共识机制是区块链事务达成分布式共识的算法。由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制

### POW

PoW即通过工作结果来证明你完成了相应的工作。POW算法原理：

- 节点通过不断地更换随机数来探寻合适的哈希值
- 当节点最先计算出合适的哈希值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中

哈希函数的特征：

- 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况

- 隐匿性，即给定一个散列值，想要反向逆推出输入值，在计算上是不可行的

- 不存在比穷举更好的方法，以使得散列值落在特定的范围

### Ethash

这是以太坊专门的POW算法，他是为了解决挖矿中心化问题，专门设计了一个能抵制ASIC、轻客户端可快速验证的PoW算法。算法流程：

- 对于每一个区块，都能通过扫描区块头的方式计算出一个种子(seed)，该种子只与当前区块有关

- 使用种子能产生一个16MB的伪随机缓存，轻客户端会存储缓存

- 基于缓存再生成一个1GB的数据集，称其为DAG。数据集中的每一个元素都只依赖于缓存中的某几个元素，也就是说只要有缓存，就可以快速地计算出DAG中指定位置的元素
- 挖矿者存储数据集，数据集随时间线性增长

- 挖矿可以概括为“矿工”从DAG中随机选择元素并对其进行散列的过程，DAG也可以理解为一个完整的搜索空间，挖矿的过程就是从DAG中随机选择元素(类似比特币挖矿中试探合适nonce的过程)进行散列运算

- 验证者只需要花费少量的内存存储缓存就可以了，因为验证者能够基于缓存计算得到DAG中自己需要的指定位置的元素，然后验证这些指定元素的散列是不是小于某个散列值，也就是验证“矿工”的工作是否符合要求

- Ethash算法的特点是挖矿的效率基本与CPU无关，而与内存大小、带宽正相关，目的是去除专用硬件的优势，抵抗ASIC(矿机)

### POS

POS即基于网络参与者目前所持有的数字货币的数量和时间进行利益分配，是一种对货币所有权的证明。共识算法类型：

- 基于链的PoS和BFT(Byzantine Fault Tolerant，拜占庭容错）风格的PoS

- 在基于链的PoS中，该算法在每个时隙内伪随机地从验证者集合中选择一个验证者(比如，设置每l0s一个周期，每个周期都是一个时隙)，给予验证者创建新区块的权利
- 但是验证者要确保该块指向最多的块(指向的上一个块通常是最长链的最后一个块)
- 因此，随着时间的推移，大多数的块都收敛到一条链上

- 在BFT风格的PoS中，分配给验证者相对的权利，让他们有权提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链
- 在每一轮中，每一个验证者都为某一特定的块进行“投票”，最后所有在线和诚实的验证者都将“商量”被给定的块是否可以添加到区块链中，并且意见不能改变

## 交易

> 以太坊的交易主要是指一条外部账户发送到区块链上另一账户的消息的签名数据包，其主要包含发送者的签名、接收者的地址以及发送者转移给接收者的以太币数量等内容。交易是以太坊整体架构中的重要部分，它将以太坊的账户连接起来，起到价值的传递作用

### 交易内容

`from`：交易发送者的地址，必填

`to`：交易接收者的地址，如果为空则意味这是一个创建智能合约的交易

`value`：发送者要转移给接收者的以太币数量

`data(也写作input)`：存在的数据字段，如果存在，则是表明该交易是一个创建或者调用智能合约交易

`Gas Limit(也写作Gas, StartGas)`：表示这个交易允许消耗的最大Gas数量

`GasPrice`：表示发送者愿意支付给矿工的Gas价格

`nonce`：用来区别同一用户发出的不同交易的标记

`hash`：由以上信息生成的散列值(哈希值)，作为交易的ID

`r、s、v`：交易签名的三个部分，由发送者的私钥对交易hash 进行签名生成

### 交易费用

> 为了防止用户在区块链公有链中发送太多的无意义交易，浪费矿工的计算资源，要求交易的发送方为每笔交易付出一定的代价，便是交易费用。由于比特币中只存在转账交易，每笔交易所需的计算开销大体一致，因此每笔交易的发送者会以比特币的形式，付出相对固定的手续费。而以太坊中引入了智能合约，涉及智能合约创建和调用的交易所消耗的计算差别巨大，因此引入了相对复杂的Gas、Gas Price对交易所需的手续费进行定价

**Gas:**

- gas是“燃料”的意思。在以太坊区块链上实现了一个EVM（以太坊虚拟机）的代码运行环境，在链上执行写入操作时，网络中的每个全节点都会进行相同的计算并存储相同的值
- 这种执行的消耗是昂贵的，为了促使大家将能在链下进行的运算都不放到链上进行，也为了奖励矿工，在链上每执行一个写入操作时，都需要支付一定的费用，用gas为单位来计数
- 每个在链上可以执行的命令都设置了一个消耗的gas值，例：`PUSH操作`需要消耗`3个gas`，`一次转账`一般要消耗`21000 gas`，gas使用`ether`来支付
- 1 ether = 1 x 10^18 wei = 1 x 10^9 Gwei

**Gas Price:**

- `Gas Price`就是你愿意为一个单位的Gas出多少`ether`，一般用`Gwei`作单位
- `Gas Price`越高，就表示交易中每运算一步，会支付更多的`ether`
- 通过`gas price`可以节省矿工费用，但也会减慢矿工打包的速度。因为，矿工会优先打包`gas price`设置高的交易，如果您想加快转账，您可以把`gas price`设置得更高，这样您就可以插队靠前
- 以太坊的交易手续费为：`TxFee = gas * gas Price`，单位`Gwei`
- `一次转账`一般要消耗`21000 gas`，如果你设置的`gas Price = 1000000000wei = 1Gwei`，则此次转账的交易手续费为：`TxFee = 21000 Gwei = 0.000021 ether`
- A账户欲向B账户转账`4 ether`，则要求A账户至少要有 `4 + 0.000021 = 4. 000021 ethrer`

> 最后值得一提的是`Gas Price`越高，你提交的交易会越快被矿工接纳。但通常人们都不愿多支付手续费，那么究竟应该将Gas Price设置为多少，才可以保证在能接受的时间内，让交易被确认到区域链上呢？
>
> 我们可以为交易定义`gas price`，具体的值可以参考[ETH gas station](https://ethgasstation.info/)。这里能看到以太坊区块链上最近完成的交易对应的消耗单价、记录时间、等待时间、手续费均价等。根据自身交易需求，我们可以参考右下`Safelow/Standard/Fast`三个速度对应的`gasPrice`

在发起交易时定义gas与gas price:

```js
eth.sendTransaction({
    from: 0x4fd9555dd1309e7a2a356ea7e92c1b41cb7bb144,
    to: 0xf7deba629960e4f31f1aba61927f6f1e966c4462, 
    value: web3.toWei(1, "ether"), 
    gas: 60000,
    gasPrice: web3.toWei(40,'gwei'),
    nonce: 30
}); 
```

**Gas Limit:**

- `Gas Limit`就是一次交易中`gas`的可用上限，也就是你的交易中最多会执行多少步运算。 由于交易复杂程度各有不同，确切的Gas消耗量是在完成交易后才会知道，因此在你提交交易之前，需要为交易设定一个Gas用量的上限
- 每个区块有`gas limit`，即单个区块允许的最多gas总量，可以用来决定单个区块中能打包多少笔交易，由矿工决定它的大小。防止矿工的资源消耗过大，造成挖出的区块无法形成最长的交易链。不过矿工也不能任意地更改区块的`Gas Limit`，根据以太坊协议，当前区块的Gas Limit只能基于上一个区块的Gas Limit上下波动1/1024
- 我们每一次交易或合约调用都要设置一个`gas limit`，如果该次操作所使用的gas数量小于或等于您所设置的`gas limit`，则会被执行。但如果gas总消耗量超过`gas limit`，所有的操作都会被重置，但费用依旧会被收取 —— 因为要奖励已经付出劳动的矿工
- 在执行中实际消耗的gas值总和叫`gas used`，`gas used`未达到`gas Limit`，那么只会按实际`gas used`收取交易服务费，没有使用完的gas会退还到原账号
- 如果尝试将一个会使用超过当前区块`gas limit`的交易打包，则会被网络拒绝，会反馈`below gas limit`

### 交易类型

1. 转账交易

```js
web3.eth.sendTransaction({
    from :"Oxb60e8dd6lc5d32be8058bb8eb970870f07233155",
    to:"Oxd46e8dd67c5d32be8058bb8eb970870f07244567",
    value: 10000000000000000
});
```

2. 创建智能合约的交易

```js
web3.eth.sendTransaction({
    from:"Oxb60e8dd6lc5d32be8058bb8eb970870f07233155",
    data :"contract binary code"
});
```

3. 执行智能合约的交易

```js
web3.eth.sendTransaction({
    from:"Oxb60e8dd6lc5d32be8058bb8eb970870f07233155",
    to:"Oxb4259e5d9bc67a0f2ce3ed372ffc5lbe46c33c4d",
    data :"hash of the invoked method signature and encoded parameters"
});
```

### 交易执行流程

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e222cb27e40~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom:52%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/fdsafasdfasdfrwqerqwerew.png" alt="fdsafasdfasdfrwqerqwerew" style="zoom:54%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e225895cfdb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom: 60%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e227df6fca2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom: 59%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/16aa4e228b061982~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="img" style="zoom: 57%;" />

## 数据编码与压缩

RLP(Recursive Length Prefix)是一种编码算法，用于编码任意的具有嵌套结构的二进制数据，是以太坊数据序列化的主要方法

# 以太坊签名

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/KYX4eZRJ636a2292a94e7.jpg" alt="yuque_diagram.jpg" style="zoom:50%;" />

## 签名概述

### 签名的作用或目的

- **身份认证**：证明你拥有地址的私钥
- **不可否认**：确认你的确发布过该消息
- **完整性**：确保信息没有被篡改

### 什么是签名

> 当我签署一份租房合同，当我们租期到时，如果对屋内的物品所有损坏，房东可凭借这份合同上的内容对我进行索赔（扣押金），如果我进行抵赖，说我没签署过这份合同，那么房东可去司法机构进行签名**笔迹认证**。以太坊中的签名也是如此，在租房合同中签名是**笔迹**，在以太坊中的签名就是**一段数据**，这段数据的作用和我签署租房合同的签名笔迹没有任何不同，节点们（矿工们、验证者们）可以凭借这段数据进行**身份认证**，即证明这些消息就是我签署的（因为只有我拥有私钥），同时我想抵赖也是不可能的，因为这段数据具备**不可否认性**，第三方也不可能对消息进行篡改，因为这段数据具备**完整性**

### 以太坊签名过程

在以太坊、比特币中这个算法是经过二开的ECDSA(原始的ECDSA只有r、s组成，以太坊、比特币的ECDSA由r、s、v组成)

- **签名过程**：ECDSA_正向算法（消息 + 私钥 + 随机数）= 签名
- **验证过程**：ECDSA_反向算法（消息 + 签名）= 公钥

## 签名交易

> ECDSA可理解为以太坊、比特币对消息、交易进行签名与验证的算法与流程

### 关键词

**签名: **

- 即`正向算法（消息 + 私钥 + 随机数）= 签名`
- 其中消息是公开的，私钥是隐私的
- 经过ECDSA正向算法可得到签名，即r、s、v

**验证: **

- 即`反向算法（消息 + 签名）= 公钥`
- 其中消息是公开的，签名是公开的
- 经过ECDSA反向算法可得到公钥，然后对比已公开的公钥

**RLP: **

- 一种序列化的方式，其与网络传输中json的序列化/反序列化有一些不同，RLP不仅兼顾网络传输，其编码特性更确保了编码后的一致性
- 因为每笔交易过程中要进行Keccak256，如果不能保证编码后的一致性，会导致其Hash值不同，那么验证者就无法验证交易是否由同一个人发出

**Keccak256: **

- 以太坊的Hash算法，生成32个字节Hash值

### **签名过程**

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/L785xw0I636a22d63a9ef.png" alt="image.png" style="zoom: 80%;background-color: white;" />

1. **构建原始交易对象**

- **nonce**: 记录发起交易的账户已执行交易总数。Nonce的值随着每个新交易的执行不断增加，这能让网络了解执行交易需要遵循的顺序，并且作为交易的重放保护
- **gasPrice**:该交易每单位gas的价格，Gas价格目前以Gwei为单位（即10^9wei），其范围是大于0.1Gwei，可进行灵活设置
- **gasLimit**:该交易支付的最高gas上限。该上限能确保在出现交易执行问题（比如陷入无限循环）之时，交易账户不会耗尽所有资金。一旦交易执行完毕，剩余所有gas会返还至交易账户
- **to**：该交易被送往的地址（调用的合约地址或转账对方的账户地址）
- **value**：交易发送的以太币总量
- data:
  - 若该交易是以太币交易，则data为空
  - 若是部署合约，则data为合约的bytecode
  - 若是合约调用，则需要从合约ABI中获取函数签名，并取函数签名hash值前4字节与所有参数的编码方式值进行拼接而成，具体参见文章[Ethereum的合约ABI拓展](https://github.com/linjie-1/guigulive-operation/wiki/Ethereum的合约ABI拓展)
- **chainId**：防止跨链重放攻击 ->EIP155

2. **签署交易**

签署交易可使用ethers库，它可以进行交易的签名，详情见如下代码：

```javascript
const ethers = require("ethers")
require("dotenv").config()

async function main() {
    // 将RPC与私钥存储在环境变量中
    // RPC节点连接，直接用alchemy即可
    let provider = new ethers.providers.JsonRpcProvider(process.env.RPC_URL)
    // 新建钱包对象
    let wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider)
    // 返回这个地址已经发送过多少次交易
    const nonce = await wallet.getTransactionCount()
    // 构造raw TX
    tx = {
      nonce: nonce,
      gasPrice: 100000000000,
      gasLimit: 1000000,
      to: null,
      value: 0,
      data: "",
      chainId: 1, //也可以自动获取chainId = provider.getNetwork()
    }
    // 签名，其中过程见下面详述
    let resp = await wallet.signTransaction(tx)
  	console.log(resp)
    // 发送交易
    const sentTxResponse = await wallet.sendTransaction(tx);
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error)
        process.exit(1)
    })
```

**wallet.signTransaction中发生了什么？**

1. 对`(nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0)`进行RLP编码
2. 对上面的RLP编码值进行Keccak256
3. 对上面的Keccak256值进行ECDSA私钥签名（即正向算法）
4. 对上面的ECDSA私钥签名(v、r、s)结果与交易消息再次进行RPL编码，即`RLP(nonce, gasPrice, gasLimit, to, value, data, v, r, s)`，可得到如下编码

```javascript
0xf8511485174876e800830f42408080802da077cdb733c55b4b9b421c9e0e54264c6ccf097e5352ab117e346b69ac09755606a03ef912e80a022713cf5ccc3856f2d4159bf47de7c14090b66ef155b10d073776
```

之所以步骤1中包含chainId字段，而步骤4中再次编码时没有chainId字段(原始消息内容都不一样，怎么可能会验证通过)，这是因为chainId是被编码到签名的`v`参数中的，因此不会将chainId本身包含在最终的签名交易数据中。当然我们也不会提供任何发送方地址，因为地址可以通过签名恢复

### 验证过程

1. 对上面最终的RPL解码，可得到`(nonce, gasPrice, gasLimit, to, value, data, v, r, s)`
2. 对`(nonce, gasPrice, gasLimit, to, value, data)`和`(v,r,s)`ECDSA验证，得到签名者的address，可以看到第一个括号少了`chainId`，这是因为`chainId`在ECDSA私钥签名时被编码到了v，所以由v可以直接解码出`chainId`(所以在对上面的RLP编码值进行Keccak256这一步，肯定是把`chainId`复制了一下，给对上面的Keccak256值进行ECDSA私钥签名这一步用)
3. 对上面得到的签名者的address与签名者公钥推导的address进行比对，相等即完成身份认证、不可否认性、完整性

### 安全问题

> 原始交易对象里有**Nonce**和**ChainID**两个字段，这是为了防范**双花攻击\重放攻击**，双花与**重放**是相对的，本质都是重复使用一个签名：
>
> - 用自己的签名做对自己有利的重复叫**双花**
> - 用别人的签名做对自己有利的重复叫**重放**

- **Nonce**：账户交易计数，以太坊的账户模型中记录着每个账户Nonce，即此账户发起过多少次交易
- **ChainId**：分叉链区分，比如我在以太坊链上给evil进行一笔转账交易，evil又可以去以太坊经典链上重放这笔交易，这时如果我在以太坊经典上也有资产，那么会遭受损失。所以EIP155提议加入ChainId，以防止跨链重放(以太坊ChainId为1，以太坊经典ChainId为61)

## 签名消息

不要把签名交易和签名消息混为一谈，以为这两个东西是平行的，各自发给节点的。这样的想法是错误的，只需记住一点，发给节点的只能是交易签名+相应参数，其大概可分为三种情况：

- **单纯的转账交易**：

  - 就是上一章节的内容，由`(nonce, gasPrice, gasLimit, to, value, data:空, chainId)`经私钥通过ECDSA正向算法得到`(v,r,s)`，将`(nonce, gasPrice, gasLimit, to, value, data:空, v, r, s)`发往节点

  - **注意:** 这里data是空的

- **部署合约交易**：

  - 由`(nonce, gasPrice, gasLimit, to:空, value, data:合约创建字节码, chainId)`经私钥通过ECDSA正向算法得到`(v,r,s)`，将`(nonce, gasPrice, gasLimit, to:空, value, data:合约创建字节码, v, r, s)`发往节点

  - **注意:** to是空的**, **data是合约创建字节码，节点看到to是空的就知道这是部署合约交易

- **调用合约函数交易**：

  - 由`(nonce, gasPrice, gasLimit, to, value, data:selector+函数参数, chainId)`经私钥通过ECDSA正向算法得到`(v,r,s)`，将`(nonce, gasPrice, gasLimit, to, value, data:selector+函数参数, v, r, s)`发往节点
  - **注意:** data是selector+函数参数，例如`bytes4(keccak256(bytes("foo(uint256,address,string,uint256[2])"))), x, addr, name, array`

综上，无论是部署合约交易还是调用合约函数交易都是改变data的值。 本节说的消息签名就是调用合约函数交易，调用对应合约函数(一般为验证verfiy函数)，消息签名作为参数。下面是调用合约函数交易+消息签名的图示(流程图+层叠图)：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/ufoipadsfjkewlfwkl.webp" alt="ufoipadsfjkewlfwkl" style="zoom:67%; background-color: white" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/7fxe6nRk636a25efa4644.png" alt="image.png" style="zoom:67%; background-color: white" />

> EIP191和EIP712标准都是为了安全，与EIP151相同，通过定义规范的格式来防止别人攻击。实际上任何两个实现逻辑相同的合约，都会存在重放攻击的风险，因此这个标准都在签名内部加上了合约地址，来防止这种攻击

# JSON-RPC

> RPC其实就是一种传输协议，他和HTTP相同，都是c/s架构，他们最本质的区别就是RPC主要是基于TCP协议的，而HTTP服务主要是基于HTTP协议的
>
> HTTP协议是在传输层协议TCP之上的，所以效率来看的话，RPC当然是要更胜一筹。RPC 主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候 RPC 的优势就比较明显了

## RPC架构

- `Client`(服务端)：服务的调用方
- `Server`(客户端)：真正的服务提供者
- `Client Stub`(客户端存根)：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方
- `Server Stub`(服务端存根)：接收客户端发送过来的消息，将消息解包，并调用本地的方法

## 同步调用与异步调用

- **同步调用：**就是客户端等待调用执行完成并返回结果
- **异步调用：**就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用

## RPC框架(JSON-RPC)

> JSON-RPC是一种基于JSON的跨语言远程调用协议。有文本传输数据小，便于调试扩展的特点

### **请求：**

```json
{ 
    "jsonrpc" : 2.0, // 定义JSON-RPC版本
    "method" : "sayHello",  // 调用的方法名
    "params" : ["Hello JSON-RPC"],  // 方法传入的参数，若无参数则为null
    "id" : 1 //调用标识符。可以为字符串，不推荐包含小数（不能准确二进制化），或为null（可能引起混乱）
} 
```

```json
 {
    "jsonrpc":"2.0",
    "method": "subtract",
    "params":{
        "subtrahend": 23,
        "minuend": 42
    }, 
    "id": 3
}
```

### **响应:**

```json
{
    "jsonrpc" : 2.0,
    "result" : "Hell JSON-RPC", // 方法返回值，调用成功时，不能为null，调用错误时，必须为null
    "error" : null, // 调用时错误，无错误返回null，有错误时则返回一个错误对象
    "id" : 1
}
```

示例：无id错误

```JSON
// 请求
{
    "jsonrpc":"2.0", 
    "method": 1, 
    "params": "bar"
}
```

```JSON
// 响应
{
    "jsonrpc": "2.0", 
    "error":{
        "code": -32600, // 一个表示错误类型的数字
        "message": "Invalid Request", // 错误描述
        "data": null // 附加信息，可为null
    },
    "id": null
}
```

错误码-32768到-32000作为预定义错误的保留值，该范围内的任何未定义代码为未来保留使用

| 代码           | 错误         | 含义                                               |
| -------------- | ------------ | -------------------------------------------------- |
| -32700         | 解析错误     | 服务器接收到无效的JSON；服务器解析JSON文本发生错误 |
| -32600         | 无效的请求   | 发送的JSON不是一个有效的请求                       |
| -32601         | 方法未找到   | 方法不存在或不可见                                 |
| -36602         | 无效的参数   | 无效的方法参数                                     |
| -36603         | 内部错误     | JSON-RPC内部错误                                   |
| -32000到-32099 | 服务器端错误 | 保留给具体实现服务器端错误                         |

## 批量调用

> 客户端可以发送一个请求对象数组来进行批量调用。当所有的请求都响应完毕后，服务器应以一个数组作为响应，每个请求都应该对应一个请求对象。服务器可以以任何宽度的并行性，以任意的顺序，并发的批量处理一个RPC调用。客户端可以通过id将请求和响应进行匹配

# web3钱包

> web3钱包是用来存储代币、NFT等数字资产的数字钱包， 我们平时常听到的加密钱包和web3钱包是同一个东西，只是叫法不一样。钱包它也是个人身份凭证，用户可以通过钱包登录各种web3 web应用和DAPP
>
> 我们讨论web3钱包时候，经常会提及秘钥、助记词、账号等词，为了更好理解其之间的关系，我们可以类比web2.0里面的保险箱。一个钱包就类似一个保险箱，秘钥和助记词相当于保险箱的的钥匙或者密码，谁拥有秘钥或助记词，谁就拥有钱包的控制权和其里面存储的数字资产。钱包和账号是一对多的关系，一个钱包可以创建多个账号，每个账号独立存储数字资产。钱包的秘钥和助记词是很重要的，如果我们的秘钥或助记词不小心被盗取，这意味着我们钱包里面的所有资产都会丢失

## 冷钱包与热钱包

### 热钱包

- 热钱包指的是能连接网络的加密钱包，热钱包是最常用的钱包，由于热钱包是连接网络的，因此它有个致命的缺点：容易受到黑客和其他的恶意攻击盗取

- 热钱包还可以更进一步分成中心化的钱包（如用户在币安、欧易等中心化交易所创建的钱包）和去中心化的钱包(如MetaMask钱包)

- 在币安等交易所里创建的钱包的最终控制权在交易所手上（类似我们在证券公司里面开的证券账号），用户只能用这些中心化钱包进行转账（接收数字资产或者发送数字资产）

- 中心化的钱包的优点: 中心化的钱包转账，提现等都需要用户进行手机短信验证码或者邮箱验证验证，相对来说就安全些。其缺点是：最终控制权在交易所手上（有交易所跑路或者封账号的风险）

- 去中心化钱包的优点：控制权完全掌握在我们手上

- 其缺点是：安全性较差、秘钥及助记词一丢失，就存在所有资产被盗被转移的风险

- 市场上很多种类的热钱包，其功能都相差不大，都具备发送数字资产、接受数字资产、作为个人凭证登录web3 Web应用和DAPP的功能，同时和智能合约进行数据通讯

- 平时较常用的钱包有MetaMask、TrustWallet。MetaMask主要在Web端，以浏览器插件形式存在。TrustWallet主要在移动端

### 冷钱包

- 不连网的钱包都叫冷钱包，冷钱包是离线存储数字资产的
- 冷钱包是最安全的钱包，由于它不连网，很少受黑客的攻击盗取
- 市场上比较常用的冷钱包主要有Trezor和Ledger，网上都有得卖，价格在几百到上千元不等

- 冷钱包主要是通过蓝牙、USB传输进行网络通讯，发送接受数字资产

## 以太坊帐户类型

> 账户是以太坊协议的核心组成部分，在每一笔交易和合约中都发挥着作用，以太坊有两种帐户类型：
>
> - **外部所有的帐户 (EOA，Externally Owned Accounts)** – 由任何拥有私钥的人控制
>
>   做EOA帐户的钱包又分为软件 EOA钱包（比如MetaMask）、硬件EOA 钱包（比如Ledger）
>
> - **合约帐户（CA，Contract Accounts）** — 部署到网络上的智能合约，由代码控制
>
>   做合约帐户的钱包又分为单签名智能合约钱包（比如Argent）、多签名智能合约钱包（比如Gnosis Safe Multisig）和托管型钱包（比如Coinbase Custody）

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/1000" alt="img" style="zoom:50%;" />

### 两种帐户的区别点：

**EOA帐户：**

> 这样的账户没有私钥，但有一个地址、代码和存储。基于合约的钱包，也被称为智能合约钱包，依靠合约账户来存储和运行代码。合约账户是由代码中的逻辑编程控制的。它没有相关的私钥，不能发起交易，但它可以在收到来自EOA的交易后执行操作（例如，调用另一个合同或转移资金）
>
> 智能合约钱包是由合约代码而不是私钥控制的，智能合约钱包与智能合约账户互动，就相当于在用户控制的账户之上有了一层自动化。这样一来智能合约就使钱包更安全，更容易使用了。由于智能合约钱包“不需要私钥”这一个优点，就使万千用户把目光投向了智能合约钱包。合约代码定义了资金如何被访问，由谁访问，以及在什么条件下访问。此外，由于智能合约是可编程的，智能钱包通常设计有比传统钱包更先进的功能

- 创建帐户是免费的

- 可以发起交易

- 外部所有的帐户之间只能进行以太币和代币交易

- 由一对加密密钥组成：控制帐户活动的公钥和私钥

**CA帐户:**

> 可以承载多种功能，最常见的是作为一个钱包或简单的私钥/地址对。大多数流行的非托管钱包都是利用外部拥有的账户。一个外部拥有的账户（EOA）是由一个相关的私钥控制的。密钥持有者可以以EOA或合同账户为收件人发起交易。EOA仅限于基本功能（如转账），因为账户的状态中没有存储代码
>
> 今天的许多钱包都是由EOA管理的，MetaMask生成的钱包账户就是EOA，这就是用户通过用私钥签署交易，从钱包转移以太币（ETH）和其他代币。我们常用的以“0x”开头的一串字符，就是都是免费生成的EOA公钥，我们还需要自己去记住并且保管一串复杂的私钥

- 创建合约存在成本，因为需要使用网络存储空间
- 只能在收到交易时发送交易
- 从外部帐户向合约帐户发起的交易能触发可执行多种操作的代码，提供很多 EOA 无法提供的高级功能，例如转移代币甚至创建新合约
- 合约帐户没有私钥。相反，它们由智能合约代码逻辑控制

## 传统(HD)钱包

> 传统钱包使用助记词和分层确定性 (HD) 结构来派生私钥、对应的公钥和链上地址。这些钱包允许用户生成用于签署交易的私钥，并使用助记词恢复所有密钥
>
> 到目前为止，传统钱包一直是用户保管资产的工具，也是他们与区块链应用程序交互的主要入口。像MetaMask这样的浏览器扩展程序和像Rainbow这样的移动应用程序已经为这个生态系统吸引了数百万用户。想要降低风险的用户可以选择Ledger和Trezor等硬件钱包，它们可以离线保护私钥，从而提供更好的安全性
>
> 虽然业界已经做出了巨大的集体努力来告知用户保持助记词和密钥安全的重要性，但这个单点故障仍然是广泛采用的一个重要障碍。如果私钥丢失，除了失去所有资产外，用户还必须手动跟踪多个地址、代币批准，并因必须为新地址提供资金而损害隐私
>
> 今天，不可撤销的字符串不仅可以让一个人的毕生积蓄全部被「访问」，而且越来越多地趋势是将用户在线身份的链上历史联系起来。获取私钥访问权的动机就是这么大，以至于黑客们，每个人都投入无限的资源，进行越来越有创意的攻击。现在，仅仅依靠用户已经不够了——我们需要完全消除这个单点故障
>
> 多方计算 (MPC) 钱包和智能合约钱包帮助我们实现这一目标，并且已经有一个由机构、个人和DAO等采用的关于这两类产品和服务的生态系统。虽然这两种类型的钱包都消除了单点故障，但它们有一些基本的技术差异，导致了不同的折中方案

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/0085E4Dcly4h8cq56l3nxj30r00f5751.jpg" alt="img" style="zoom:67%;" />

### 托管钱包

> **托管类型钱包**不提供用户私钥或者会把私钥存储在自己的服务器中

**托管类型钱包的主要优点是:**

- 如果用户丢失私钥，可以在服务器端恢复自己的账户
- 更倾向于便捷地使用钱包的用户，会选择托管类型钱包

**托管类型钱包的缺点是：**

- 服务提供商可能会出于系统维护或者KYC（Know Your Customer，实名制）等原因冻结用户资产
- 同时还有资金被黑客盗走的风险

中心化的交易所也属于此种类型，已有多起交易所资金被黑客盗走事件发生。用户的资产实际被交易所掌控，交易所可能会出于KYC(Know Your Customer，实名制)或者AML(Anti Money Laundering，反洗钱)等原因冻结用户资产

### 自管钱包

> **非托管类型钱包**让用户全然掌控自己的资产，并且几乎不提供服务器端的解决方案。私钥会被加密存储在用户的设备中，并且不会传送出设备。用户100%掌控自己的资产，但非托管类型也有缺点：如果用户丢失自己的助记词，那么用户将无法恢复自己的资产

## MPC钱包

> 多方计算（MPC）或安全MPC（SMPC）是一种重要的加密安全措施，**它使多方能够在不泄露任何私人信息或每一方持有的相关秘密数据的情况下评估一项计算。**由于技术的进步和互联网的普及，数据安全和隐私保护已被证明具有挑战性，特别是当数据在大型分布式网络中传播时。MPC是一项关键技术，为数据安全和隐私问题提供了一个值得信赖的解决方案，特别是在区块链应用的背景下
>
> **举一个例子：**两个百万富翁在街上相遇，他们都想知道谁更富有，但又不愿意让对方知道自己拥有的真正财富。如何在没有第三方的情况下，让对方知道谁更有钱？
>
> 在密码学领域，这个问题可以描述成：“一组互不信任的参与方之间在保护隐私信息以及没有可信第三方的前提下的协同计算问题。”
>
> 多方计算 (MPC) 是一种加密工具，它允许多方使用他们的组合数据进行计算，而无需透露他们的个人输入。在这种情况下，MPC协议将利用一个公认的密码学概念，即加法秘密共享，这需要在一群独立的当事人之间分割和流通一个秘密

MPC钱包是一种需要一个以上的参与者来授权交易的加密钱包。它被称为“多方计算”，需要多方计算是因为生成钱包密钥和创建数字签名的过程是由运行分布式计算协议的不同各方执行的

传统的加密货币钱包（如MetaMask）有一个单一的私钥和一个助记词来恢复丢失的私钥。由于从钱包中移动资金是通过私钥授权，因此保持它的安全是很重要的

然而，如果出现单点故障，比如你忘记了私钥，或者被人恶意使用，存储在钱包中的资金可能被盗或永远无法使用

而在MPC的范式下，我们创建并分发私钥的一部分，这样每一方本身并不持有单独的私钥，他们只拥有密钥的一部分（称为分片或密钥份额）——这个过程被称为分布式密钥生成 (DKG)。然后，我们可以通过合并部分，并且在不暴露各方之间的部分的情况下共同生成公钥。如果要对消息和交易进行签名，所有各方都将他们的密钥份额应用于该交易，这是为该钱包创建有效数字签名的唯一方法

通过多方计算，那些参与密钥生成和签署的人永远不必透露他们输入的密码。因此，如果黑客破坏了一个单一的密钥碎片，但由于未经授权，还是不能从MPC钱包转移资金。只有当所有各方同时被破坏时，攻击者才有可能入侵一个MPC钱包

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/0085E4Dcly4h8cq57s06oj30r00f5751.jpg" alt="img" style="zoom:67%;" />

如上图所示：为了对消息和交易进行签名，每一方都要输入秘密共享部分(分片密钥)与公共输入(要签名的消息)，以生成数字签名。由于每个人生成的数字签名都是通过部分密钥生成的，所以并不能被公钥所验证，所以要通过钱包使用MPC算法合并这些信息，才能生成真正的签名消息

这样任何知道公钥的人(即验证者节点)都应该能够验证和验证签名。由于密钥部分是被组合的，签名是在链下生成的，因此从MPC钱包生成的交易与传统的私钥钱包的交易没有区别

## **智能合约钱包**

> 以太坊目前有两种账户类型:
>
> - 外部拥有帐户(EOA) —— 由私钥控制
>
> - 智能合约帐户 —— 由代码控制
>
> 智能合约钱包(「智能钱包」)是一种行为类似于钱包的智能合约，即一个允许用户管理资金、进行web3登录和与dApp交互的界面。与私钥钱包不同的是，智能钱包的创建需要初始成本，因为智能合约需要部署在链上
>
> 多重签名钱包是智能合约钱包，它需要M-of-N密钥的签名才能执行交易。MPC只创建单个签名，而不管参与的密钥共享的数量，多重签名使用由不同私钥生成的不同签名对交易进行签名。这使得它与现有的私钥钱包兼容，并位于Ledger或MetaMask等传统钱包地址之上的一层

- 下面这个智能合约钱包相当于实现了==共管钱包==

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/0085E4Dcly4h8cq58xsvhj30r00f7aar.jpg" alt="img" style="zoom:67%;" />

像Safe这样的智能合约账户标准为资产管理产品和服务的生态系统提供了一个基础层。功能是通过模块添加的，它允许用户定义管理密钥逻辑、支出限制、重复交易、帐户自动化、分层访问等等。目前最多产的一组Safe模块是由Zodiac团队构建的

# 区块链1.0与2.0的区别

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130120021380.png" alt="image-20230130120021380" style="zoom: 80%; " />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130120046393.png" alt="image-20230130120046393" style="zoom:80%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img-2/image-20230130120106530.png" alt="image-20230130120106530" style="zoom:80%;" />

# Infura

按照常规定义，Infura是一种IaaS（Infrastructure as a Service）产品，一个托管的以太坊节点集群，可以将你开发的以太坊智能合约部署到infura提供的节点上，而无需搭建自己的以太坊节点，从而大大降低访问以太坊数据的门槛

通俗一点讲，Infura就是一个可以让你的DAPP或者交易所快速接入以太坊的平台，不需要本地运行以太坊节点

从以太坊运行到现在，有大量的交易被打包，导致的结果就是全节点的大小急剧增加，下载同步一个全节点往往要好几天，并且还会出现偶尔信息不同步的情况，所以大部分时候假如你想做关于全节点的开发，可以使用infura提供的节点

如果你使用过MetaMask，那么就已经接触过Infura了，因为它是MetaMask背后的以太坊供应商，因此当Infura以太坊API服务中断后，MetaMask也会受到影响

从程序员的角度讲，Infura就是一个Web3 Provider，背后是负载均衡的API节点集群。使用它的好处就是，你永远不必担心连接的节点失效的问题，Infura会管理好这一切。除此之外，Infura还可以很方便地接入IPFS

# Geth简介

> Geth又名go-ethereum,是ethereum协议的具体落地实现，通过geth，可以实现ethereum的各种功能，Geth可以被安装在很多操作系统上，包括Windows、Linux、Mac、Android或者iOS系统

**Geth客户端主要功能:**

- JavaScript Console：通过后台进行命令操作

- Management API：管理相关的API

- JSON-RPC server：JSON-RPC相关调用API

- 账号管理（创建账号、锁定账号、解除锁定等）

- 查询账户信息

- 查询交易信息

- 查询gasPrice

- 交易

- 挖矿&停止挖矿

- 部署智能合约