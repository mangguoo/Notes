## 微信公众平台概述

### 微信公众平台介绍

> 微信公众号是开发者或商家在微信公众平台上申请的应用账号，通过公众平台，商家可在微信平台上实现和特定群体的文字、图片、语音、视频的全方位沟通、互动。形成了一种主流的线上线下微信互动营销方式。
>
> 公众号认证一次需要300元人民币，每年都需要认证一次。在公司开发业务都要认证，认证后公众号平台会给你开通更多的权限。
>
> 微信公众平台：https://mp.weixin.qq.com

### 微信公众平台的类型

> 订阅号可以个人和企业组织都可以申请，而后两者只能是企业或组织才可以申请，订阅号消息的显示在“**订阅号**”文件夹中，而后两者直接显示在好友对话列表中，订阅号每天都可以群发1条消息，服务号1个月可以群发4条消息，企业微信没有此项功能。

- 订阅号：用于服务类功能

- 服务号：用于资讯或推广

- 企业微信：用于企业内部

### 微信公众平台的两种运行模式

#### 编辑模式

> 使用微信公众号提供的统一的微信公众管理平台，进行操作。所有功能都已经写好，直接使用即可。只需要编辑相关内容信息。适合不会编程的人使用。一般企业不用。

#### 开发者模式

> 微信公众平台提供了**服务器(开发者服务器)**接入的方式，具有开发能力的运营者，可以进行定制开发。
>
> 开发者模式:需要一台或多台外网能访问到的服务器 (需要外网服务器运行[上线])
>
> 注意：微信公众平台管理中，编辑模式和开发者模式是**互斥**的，也就是说只能使用其中一种。

**开发者模式有2种请求方式：(被动请求和主动请求)**

- 被动请求：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/%E8%BF%90%E8%90%A5%E6%88%90%E6%9C%AC%E5%90%89%E6%A0%BC%E6%96%AFf.png" alt="运营成本吉格斯f" style="zoom:50%;" />

- 主动请求：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/2.png" alt="2" style="zoom:50%;" />

## 开发公众号准备

> 因为在开发模式下面，需要一或N台外网服务器，给微信公众平台服务器能访问到，可以使用云主机或公司机房实体机，但是在开发或学习阶段，可以直接使用内网穿透。
>
> 内网穿透可以使用natapp软件,它给我们提供一个外网的域名，通过此软件，把我们内网web服务器的**IP**和**端口**，映射到natapp的外网服务器上面，这样公众号服务器访问到natapp的服务器，然后natapp服务器在通过natapp软件在把请求转发到内网中，从而就实现了内网的穿透。

### config.ini

```json
#将本文件放置于natapp同级目录 程序将读取 [default] 段
#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置
#命令行参数 -config= 可以指定任意config.ini文件
[default]
authtoken=dd8060448287625b      #对应一条隧道的authtoken
clienttoken=                    #对应客户端的clienttoken,将会忽略authtoken,若无请留空,
log=none                        #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为none
loglevel=ERROR                  #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUG
http_proxy=                     #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空
```

### 注意事项

- 免费版本不要关闭cmd窗口或者结束程序的运行，这样会导致外网域名变化

- 本机WEB服务器对应端口号和natapp指定的端口号必须一致

- natapp面板解析

  <img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/456465461.png" alt="456465461" style="zoom:50%;" />

## 开发模式

### 公众号接入

> 开发学习阶段，使用测试平台来进行：
>
> https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login
>
> 接入流程文档：
>
> https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421135319

**接入过程：**

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/%E9%AD%82%E7%89%B5%E6%A2%A6%E8%90%A6%E5%A1%94%E9%A1%B6%E5%A1%94%E9%A1%B6.png" alt="魂牵梦萦塔顶塔顶" style="zoom: 67%;" />

- 在测试平台中填写真实可连接的外网地址和token值，这里的token表示约定好的对称加密密钥

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/fjdklasfj;alsd.png" alt="fjdklasfj;alsd" style="zoom:67%;" />

- 按照官方接入文档中的加密和验证方案进行加密和验证

> 开发者通过检验 signature 对请求进行校验（下面有校验方式）。若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：
>
> - 将token、timestamp、nonce三个参数进行字典序排序
>
> - 将三个参数字符串拼接成一个字符串进行sha1加密 
>
> - 开发者获得加密后的字符串可与 signature 对比，因为标识该请求来源于微信，如果加密结果与该标识不符，则证明此次请求可能不是微信公众号服务器发来的(应不予理会)。

```js
// 注意：公众平台中的验证url为：http://xteert.natappfree.cc/weChat
// 因为这里的路由为：/weChat
const sha1 = require('sha1')
app.get('/wechat', (req, res) => {
  let { signature, timestamp, nonce, echostr } = req.query
  let arr = [token, timestamp, nonce].sort()
  let cryptStr = sha1(arr.join(''))
  if (signature === cryptStr) {
    res.send(echostr)
  } else {
    res.send('')
  }
})
```

- 配置好接入验证就可以在公众平台中点击验证了，然后公众平台就会发送4个参数到我们填写的公网服务器中(通过GET请求)，如果能够顺利访问，并且我们正确的返回了echostr字段，那么公众平台中就会提示验证成功

| signature | 微信加密签名，signature结合了开发者填写的 token 参数和请求中的 timestamp 参数、nonce参数。 |
| --------- | ------------------------------------------------------------ |
| timestamp | 时间戳                                                       |
| nonce     | 随机数                                                       |
| echostr   | 随机字符串                                                   |

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/jfdaskljfhiowenmfa.png" alt="jfdaskljfhiowenmfa" style="zoom: 67%;" />

## 被动回复消息

> 当普通用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上。此时服务器可以对本次接受到的消息进行一次响应的回复，现支持回复类型有：文本、图片、图文、语音、视频、音乐。
>
> 严格来说：发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复(响应)。

### 回复文本消息

- **/router/weChat.js**

```js
const router = require('express').Router()
const wechatController = require('../controller/wechatController')

router.get('/wechat', wechatController.wechat)
router.post('/wechat', wechatController.wechatAction)

module.exports = router
```

- **/controller/wechatController.js**

```js
const xml2js = require('xml2js')
const sendMethod = require('../msgData')
// 此值是你和公众平台的约定，不会通过网络直接传输,这样也是为了安全
const token = 'ilmango'

module.exports = {
  // ....
  wechatAction(req, res) {
    let postXmlData = []
    // post传过来的数据都是数据流，不能直接通过req.body获取
    req.on('data', chunk => postXmlData.push(chunk))
    req.on('end', async () => {
      // 得到公众平台post发送过来的所有的xml内容 string
      let xmlStr = Buffer.concat(postXmlData).toString('utf-8')
      // 将xml转换成js对象以方便更好的去操作
      const xmlParser = new xml2js.Parser()
      // 解析为xml的json对象
      let { xml } = await xmlParser.parseStringPromise(xmlStr)
      // 公众平台的id号
      const toUserName = xml.ToUserName[0]
      // 发送给公众平台的微信在此平台的唯一id值
      const fromUserName = xml.FromUserName[0]
      // 消息类型 text image voice video music news
      const msgType = xml.MsgType[0]
      // 发送过来的消息内容
      const content = xml.Content[0]
      // 这里对返回的xml数据进行封装，通过msgType来区分要返回什么结构的数据
      const sendXml = sendMethod(msgType, fromUserName, toUserName, content)
      // 被动响应
      res.send(sendXml)
    })
  }
}
```

- **/src/msgData/index.js**

```js
const methods = {
  createTextXml(fromUserName, toUserName, content) {
    // 发送的时间
    const createTime = Math.floor(Date.now() / 1000);
    // 回复给公众平台的xml，这里from和to角色要互换一下
    return `<xml>
      <ToUserName><![CDATA[${fromUserName}]]></ToUserName>
      <FromUserName><![CDATA[${toUserName}]]></FromUserName>
      <CreateTime>${createTime}</CreateTime>
      <MsgType><![CDATA[text]]></MsgType>
      <Content><![CDATA[${content}]]></Content>
    </xml>`;
  },
};

// 给出一个统一暴露所有消息类型的接口
module.exports = function (name, fromUserName, toUserName, content) {
  name = name[0].toLocaleUpperCase() + name.slice(1);
  return methods[`create${name}Xml`](fromUserName, toUserName, content);
};
```

### 回复图文消息

- **/controller/wechatController.js**

```js
const xml2js = require('xml2js')
const sendMethod = require('../msgData')
// 此值是你和公众平台的约定，不会通过网络直接传输,这样也是为了安全
const token = 'ilmango'

module.exports = {
  // ....
  wechatAction(req, res) {
    let postXmlData = []
    // post传过来的数据都是数据流，不能直接通过req.body获取
    req.on('data', chunk => postXmlData.push(chunk))
    req.on('end', async () => {
      // 得到公众平台post发送过来的所有的xml内容 string
      let xmlStr = Buffer.concat(postXmlData).toString('utf-8')
      // 将xml转换成js对象以方便更好的去操作
      const xmlParser = new xml2js.Parser()
      // 解析为xml的json对象
      let { xml } = await xmlParser.parseStringPromise(xmlStr)
      // 公众平台的id号
      const toUserName = xml.ToUserName[0]
      // 发送给公众平台的微信在此平台的唯一id值
      const fromUserName = xml.FromUserName[0]
      // 消息类型 text image voice video music news
      let msgType = xml.MsgType[0]
      // 发送过来的消息内容
      let content = xml.Content ? xml.Content[0] : ''
      // 根据用户输入的数据来决定要返回什么内容，注意这里先判断用户发送的是什么内容，这里只有用户发送文件时才会进行响应
      if ('text' === msgType) {
        if (content.includes('天气')) { // 接收类型为text，返回类型也为text，不需要修改
          content = '有大风，会很冷，多穿衣服，少说话，多面试' // 要给用户返回的内容
        }
        if (content === '图文') {
          msgType = 'news' // 要给用户返回的数据类型
          content = { // 要给用户返回的内容
            title: '养了9个月卖了4000块@@',
            description: '当孩子做了正确的事或者取得了好的成绩时，无论是家长还是老师，总会想着给孩子一些奖励，什么样的奖励才是最好的呢',
            picurl: 'https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TKfXAxcC7D0RkG~noop.image?_iz=58558&from=article.pc_detail&x-expires=1666926824&x-signature=JHtSD3qlR1Nj9AVM678%2FCVftEVI%3D',
            url: 'https://www.toutiao.com/article/7156030679283663395/?log_from=861dd6a071e1a_1666322030432'
          }
        }
        const sendXml = sendMethod(msgType, fromUserName, toUserName, content) // 把数据嵌入xml模板
        res.send(sendXml)
      } else { // 如果没有找到相应的关键字，则返回空
          res.send('')
      }
    })
  }
}
```

- **/src/msgData/index.js**

```js
const methods = {
  // 文本消息模板
  createTextXml(fromUserName, toUserName, content) {
    const createTime = Math.floor(Date.now() / 1000)
    // 回复给公众平台的xml，所以你原来接受的from和to角色要互换一下
    return `<xml>
    <ToUserName><![CDATA[${fromUserName}]]></ToUserName>
    <FromUserName><![CDATA[${toUserName}]]></FromUserName>
    <CreateTime>${createTime}</CreateTime>
    <MsgType><![CDATA[text]]></MsgType>
    <Content><![CDATA[${content}]]></Content>
  </xml>`
  },

  // 图文消息，只能发送1条
  createNewsXml(fromUserName, toUserName, content) {
    const createTime = Math.floor(Date.now() / 1000)
    return `<xml>
      <ToUserName><![CDATA[${fromUserName}]]></ToUserName>
      <FromUserName><![CDATA[${toUserName}]]></FromUserName>
      <CreateTime>${createTime}</CreateTime>
      <MsgType><![CDATA[news]]></MsgType>
      <ArticleCount>1</ArticleCount>
      <Articles>
        <item>
          <Title><![CDATA[${content.title}]]></Title>
          <Description><![CDATA[${content.description}]]></Description>
          <PicUrl><![CDATA[${content.picurl}]]></PicUrl>
          <Url><![CDATA[${content.url}]]></Url>
        </item>
      </Articles>
    </xml>`
  },
}

module.exports = function (name, fromUserName, toUserName, content) {
  name = name[0].toLocaleUpperCase() + name.slice(1)
  return methods[`create${name}Xml`](fromUserName, toUserName, content)
}
```

## 主动发送消息

### 获取access_token

> - access_token是公众号的**全局唯一**接口调用凭据，公众号调用各接口时都需使用它。
>
> - access_token的存储至少要保留512个字符空间。(如果你要存储到mysql中注意设置字段长度)
>
> - access_token的有效期目前为2个小时。
>
> - access_token的每天请求的次数为2000次。(访问量大的话需要做缓存)
>
> - access_token 新老切换的缓冲时间为5分钟内，两者都可用。(微信传回的token信息中，有一个的过期时间expeir，当这个时间显示过期后，在五分钟内仍然是可以访问的，因此不需要担心token突然失效)

**接口调用请求说明**

> https请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET

**参数说明**

| 参数       | 是否必须 | 说明                                  |
| :--------- | :------- | :------------------------------------ |
| grant_type | 是       | 获取access_token填写client_credential |
| appid      | 是       | 第三方用户唯一凭证                    |
| secret     | 是       | 第三方用户唯一凭证密钥，即appsecret   |

**返回说明**

正常情况下，微信会返回下述 JSON 数据包给公众号：

```json
{"access_token":"ACCESS_TOKEN","expires_in":7200}
```

**参数说明**

| 参数         | 说明                   |
| :----------- | :--------------------- |
| access_token | 获取到的凭证           |
| expires_in   | 凭证有效时间，单位：秒 |

错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为 AppID 无效错误）:

```json
{"errcode":40013,"errmsg":"invalid appid"}
```

**获取access_token示例：**

- **/utils/tools.js**

```js
const fs = require('fs')
const path = require('path')
const axios = require('axios')

// 测试号信息，用于请求微信公众平台的凭据
const appid = 'wxae077dbd6d0b42b8'
const secret = '12692272e71906eacbdde9e3023e3062'

const getAccessToken = async () => {
  // access_token缓件文件所在的位置，这里在文件名中加入了appid，这是由于该服务器可以会被多个公众号接入，因此可以会保存多个token，为了防止混乱，则使用作为公众号标识的appid作为文件名
  let tokenCacheFilePath = path.resolve(`./cache/${appid}_token.db`)
  // token过期时间为两小时，这里让他每一小时重复请求一次
  let expire = 3600000
  // 保存请求到的token
  let accessToken = ''
  // 判断当前文件是否存在，如果存在，则判断当前文件最后的修改时间+过期时间值，是否大于当前时间，如果大于，则表没有过期，如果小于则过期，就需要重新来获取
  if (fs.existsSync(tokenCacheFilePath)) {
    let stat = fs.statSync(tokenCacheFilePath)
    let expireTime = stat.mtime.getTime() + expire
    let currentTime = Date.now()
    if (currentTime < expireTime) {
      let accessToken = fs.readFileSync(tokenCacheFilePath, 'utf-8')
      return accessToken
    }
  }
  // 文件不存在或过期
  let url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${secret}`
  // 发起get请求
  let ret = await axios.get(url)
  // 保存请求到的token
  accessToken = ret.data.access_token
  // 写入到缓存中
  fs.writeFileSync(tokenCacheFilePath, accessToken)
  // 返回token
  return accessToken
}

module.exports = {
  getAccessToken
}
```

### 上传素材

> 公众号经常有需要用到一些临时性的多媒体素材的场景，例如在使用接口特别是发送消息时，对多媒体文件、多媒体消息的获取和调用等操作，是通过media_id来进行的。公平平台提供了两种素材模式，一是临时素材，二是永久素材，分别使用不同的接口。他们的区别就是临时素材保存三天后会自动被删除，而永久素材不会被删除，但是有上限。

**安装依赖：**

> npm install form-data concat-stream --save

由于node中不支持form-data，因此这里需要安装第三方依赖。form-data创建出来的formData对象支持管道pipe，因此它可以和concat配合的很好。

concat-stream用于连接多个数据流，流发出许多缓冲区。如果您想收集所有的缓冲区，并且当流结束时将所有的缓冲区连接在一起并接收一个单独的缓冲区，那就可以使用concat-stream。readStream一般是接入writeStream中，以直接输出文件，如果只是想把读写流的缓存片断连接起来，而不是输出到文件中，就可以直接把readStream连接到concatStream中，concatStram接收一个回调函数，这个回调函数的参数就是连接完成的缓冲区。

```js
var fs = require('fs')
var concat = require('concat-stream')
 
var readStream = fs.createReadStream('cat.png')
var concatStream = concat(gotPicture)
 
readStream.on('error', handleError)
readStream.pipe({ encoding: 'buffer' }, concatStream)
 
function gotPicture(imageBuffer) {
  // imageBuffer is all of `cat.png` as a node.js Buffer
}
 
function handleError(err) {
  // handle your error appropriately here, e.g.:
  console.error(err) // print the error to STDERR
  process.exit(1) // exit program with non-zero exit code
}
```

- **/router/weChat.js（编写上传临时素材的接口）**

> 如果有数据库，可以把上传成功的media_id数据存储在数据库中,这样在需要media_id时,就可以读取数据表中的数据来用，数据库字段如下：
>
> | 唯一标识 | 媒体id(标识媒体数据) | 媒体数据类型 | 是否为永久存储 | 本地服务器中的真实媒体数据地址 | 媒体文件上传时间戳 |
> | -------- | -------------------- | ------------ | -------------- | ------------------------------ | ------------------ |
> | id       | media_id             | type         | isforver       | filepath                       | ctime              |
>
> 可以通过isforever来判断该媒体资源在公众平台中是否是永久存储的，如果不是，可以根据创建时间加上过期时间，来判断资源是否失效，如果失效则可以重新上传，然后用新的media_id来替换旧的media_id，也可以直接删除掉该资源，通过realpath来删除掉本地存储的媒体资源。

```js
const router = require('express').Router()
const { getAccessToken } = require('../utils/tools')

// 素材上传功能所用到的类库
const FormData = require('form-data')
const concat = require('concat-stream')
const axios = require('axios')
const fs = require('fs')
const path = require('path')

// ... ...

// 定义一个可以上传服务器上面的资源到公众平台上，并且要求它返回media_id
router.get('/material', async (req, res) => {
  let type = req.query.type || 'image'
  let accessToken = await getAccessToken()
  // 上传到公众平台中的post请求地址
  let url = `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=${accessToken}&type=${type}`
  // 使用post提交一个表单的形式来提交图片(平台要求),在node环境中需要下载form-data包，如果是在浏览器环境中，则是直接内置的
  let formData = new FormData()
  // 先通过前端把图片上传该图片到该服务器中的指定地址，然后再把该图片摄像头到公众平台，获取media_id
  formData.append('media', fs.createReadStream(path.resolve('./uploads/face.jpg')))
  formData.pipe(
    concat({ encoding: 'buffer' }, async data => {
      // data就是连接完成的buffer格式的表单数据，可以直接将它作为请求体，把图片上传到公众平台
      let result = await axios.post(url, data, {
        headers: {
          'content-type': 'multipart/form-data'
        }
      })
      // 返回media_id
      res.send(result.data)
    })
  )
})

module.exports = router
```

### 回复图片、视频消息

- **/controller/wechatController.js**

```js
const xml2js = require('xml2js')
const sendMethod = require('../msgData')
// 此值是你和公众平台的约定，不会通过网络直接传输,这样也是为了安全
const token = 'ilmango'

module.exports = {
  // ....
  wechatAction(req, res) {
    let postXmlData = []
    // post传过来的数据都是数据流，不能直接通过req.body获取
    req.on('data', chunk => postXmlData.push(chunk))
    req.on('end', async () => {
      // 得到公众平台post发送过来的所有的xml内容 string
      let xmlStr = Buffer.concat(postXmlData).toString('utf-8')
      // 将xml转换成js对象以方便更好的去操作
      const xmlParser = new xml2js.Parser()
      // 解析为xml的json对象
      let { xml } = await xmlParser.parseStringPromise(xmlStr)
      // 公众平台的id号
      const toUserName = xml.ToUserName[0]
      // 发送给公众平台的微信在此平台的唯一id值
      const fromUserName = xml.FromUserName[0]
      // 消息类型 text image voice video music news
      let msgType = xml.MsgType[0]
      // 发送过来的消息内容
      let content = xml.Content ? xml.Content[0] : ''
      // 根据用户输入的数据来决定要返回什么内容，注意这里先判断用户发送的是什么内容，这里只有用户发送文件时才会进行响应
      if ('text' === msgType) {
		// ... ...
        if (content === '图片') {
          msgType = 'image' // 要给用户返回的数据类型
          // 要给用户返回的内容, 通过素材管理中的接口上传多媒体文件，得到的id。
          content = 'gDE3n-X71Pi1i7aNzNcsO4ZgWFFb9FKINZII0XIov3g_m8XQxZNX0dBdpMSu6XSO'
        }
        if (content === '视频') {
          msgType = 'video' // 要给用户返回的数据类型
          content = { // 要给用户返回的内容
            mediaId: 'gDE3n-X71Pi1i7aNzNcsO85GYQ_1RyYL9OzroAzqEl6b1mHeSpdFQzCYz8265GJz',
            title: '你好视频',
            description: '这就是一个视频'
          }
        }
        const sendXml = sendMethod(msgType, fromUserName, toUserName, content) // 把数据嵌入xml模板
        res.send(sendXml)
      } else { // 如果没有找到相应的关键字，则返回空
          res.send('')
      }
    })
  }
}
```

- **/src/msgData/index.js**

```js
const methods = {
  // ... ...
  // 图片消息模板
  createImageXml(fromUserName, toUserName, mediaId) {
    const createTime = Math.floor(Date.now() / 1000)
    return `<xml>
      <ToUserName><![CDATA[${fromUserName}]]></ToUserName>
      <FromUserName><![CDATA[${toUserName}]]></FromUserName>
      <CreateTime>${createTime}</CreateTime>
      <MsgType><![CDATA[image]]></MsgType>
      <Image>
        <MediaId><![CDATA[${mediaId}]]></MediaId>
      </Image>
    </xml>
    `
  },
  // 视频消息模板
  createVideoXml(fromUserName, toUserName, content) {
    const createTime = Math.floor(Date.now() / 1000)
    return `<xml>
      <ToUserName><![CDATA[${fromUserName}]]></ToUserName>
      <FromUserName><![CDATA[${toUserName}]]></FromUserName>
      <CreateTime>${createTime}</CreateTime>
      <MsgType><![CDATA[video]]></MsgType>
      <Video>
      <MediaId><![CDATA[${content.mediaId}]]></MediaId>
      <Title><![CDATA[${content.title}]]></Title>
      <Description><![CDATA[${content.description}]]></Description>
    </Video>
    </xml>
    `
  }
}

module.exports = function (name, fromUserName, toUserName, content) {
  name = name[0].toLocaleUpperCase() + name.slice(1)
  return methods[`create${name}Xml`](fromUserName, toUserName, content)
}
```

### 群发消息

> 订阅号每天可以群发一条消息，而服务号每个月可以群发四条消息，群发消息中的图文消息有一个限制，那就是一个图文消息只能支持1到8条图文
>
> 群发图文消息需要先上传素材，然后才能得到media_id。得到media_id后才能群发消息，并且群发后的消息不会马上推送给的关注的粉丝，它会有一段时间的延时，如果想要立即查看推送的群发消息，可以取消关注再重新关注。

```js
const router = require('express').Router()
const { getAccessToken } = require('../utils/tools')

// 上传要群发的图文消息列表，获取media_id
router.get('/upmpnews', async (req, res) => {
  let accessToken = await getAccessToken()
  var url = `https://api.weixin.qq.com/cgi-bin/media/uploadnews?access_token=${accessToken}`
  let postData = {
    articles: [
      {
        // 缩略图id, 列表的第一条图文消息的缩略图会显示为大图(封面)
        thumb_media_id: 'gDE3n-X71Pi1i7aNzNcsOzhvkHUzMGF50AUSYNClN0ltOM8Ta7Qisw79HypqAlUh',
        author: '张三', // 作者
        title: '湖北襄阳教育系统实施“四大工程”打造清廉学校', // 标题
        content_source_url: 'www.qq.com', // 阅读原文链接到的地址
        content: '... ...', // 正文内容
        digest: 'digest', // 摘要
        show_cover_pic: 1, // 是否显示封面
        need_open_comment: 1, // 是否打开评论
        only_fans_can_comment: 1 // 是否仅为粉丝才可以评论
      },
      {
        // 除第一条消息外会显示为图标
        thumb_media_id: 'gDE3n-X71Pi1i7aNzNcsOzhvkHUzMGF50AUSYNClN0ltOM8Ta7Qisw79HypqAlUh',
        author: '李四',
        title: '千锋学员：大四仔闯IT，刚毕业拿下13k',
        content_source_url: 'www.qq.com',
        content: '... ...',
        digest: 'digest',
        show_cover_pic: 0,
        need_open_comment: 1,
        only_fans_can_comment: 1
      }，
      // ... ...
    ]
  }
  let ret = await axios.post(url, postData)
  res.send(ret.data)
})

// 通过获取到的media_id群发消息
router.get('/mpnews', async (req, res) => {
  let accessToken = await getAccessToken()
  let url = `https://api.weixin.qq.com/cgi-bin/message/mass/sendall?access_token=${accessToken}`
  let postData = {
    filter: {
      is_to_all: true
    },
    mpnews: {
      media_id: '28Ne3ao4EAC-9IV1e6dFGw0PrPKZbLbrEg6MO3MzyG8jtzmfkB4GjxSvuTymKalp'
    },
    msgtype: 'mpnews',
    send_ignore_reprint: 0
  }
  let ret = await axios.post(url, postData)
  res.send(ret.data)
})

module.exports = router
```

## 自定义菜单

> 微信公众号默认没有开通底部菜单功能，需要使用者自行来创建开通。
>
> **注意点：**
>
> - 自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。
>
> - 一级菜单最多4个汉字，二级菜单最多8个汉字，多出来的部分将会以“...”代替。
>
> - 创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。
>
> - 最常用的自定义类型按钮为：
>   - view 它相当于html中的a标签的作用  
>   - click 触发事件，触发后会请求我们服务器中的/weChat的post接口，因此我们可以在这里判断消息类型，如果是事件就要判断它是什么事件(如果我们把按钮设为click，则需要额外传入一个keys属性，它就表示事件标识)，然后进行相应的处理
>   - miniprogram 点击miniprogram类型的按钮可以跳转到小程序中

### 创建菜单：

```js
const router = require('express').Router()
const { getAccessToken } = require('../utils/tools')

router.get('/createMenu', async (req, res) => {
  let accessToken = await getAccessToken()
  let url = `https://api.weixin.qq.com/cgi-bin/menu/create?access_token=${accessToken}`
  let postData = {
    button: [
      {
        name: '学习资源',
        sub_button: [
          {
            type: 'view',
            name: 'B站直达',
            url: 'http://www.soso.com/'
          },
          {
            type: 'view',
            name: '直播预约',
            url: 'https://m.baidu.com/'
          }
        ]
      },
      {
        type: 'click',
        name: '视频教程',
        key: 'click001'
      },
      {
        name: '砸蛋赢奖',
        sub_button: [
          {
            type: 'view',
            name: '抽奖入口',
            url: 'http://www.soso.com/'
          },
          {
            type: 'click',
            name: '咨询小千',
            key: 'click002'
          }
        ]
      }
    ]
  }
  let ret = await axios.post(url, postData)
  res.send(ret.data)
})

module.exports = router
```

### 删除菜单

```js
const router = require('express').Router()
const { getAccessToken } = require('../utils/tools')

router.get('/delMenu', async (req, res) => {
  let accessToken = await getAccessToken()
  let url = `https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=${accessToken}`
  let ret = await axios.get(url)
  res.send(ret.data)
})

module.exports = router
```

## 事件(订阅事件和按钮事件)

> 当用户订阅本公众号时，应该把用户数据记录到数据库中，数据表设计如下：
>
> | id       | openid                     | active                         | ctime        | mtime        | leavel1    | leavel2    | leavel3    |
> | -------- | -------------------------- | ------------------------------ | ------------ | ------------ | ---------- | ---------- | ---------- |
> | 唯一标识 | 用户对应该公众平台的唯一id | 是否关注：0为没有关注，1为关注 | 初次关注时间 | 再次关注时间 | 一级分销商 | 二级分销商 | 三级分销商 |

- **/utils/db.js**

```js
const mysql = require('mysql')
// 连接数据库,以数据库连接池的方案来，这样效率会更高一些
const db = mysql.createPool({
  connectionLimit: 2, // 创建多少个连接句柄(连接池中保持连接状态的连接数)
  database: 'wechat', // 数据库的名称
  user: 'root', // 连接数据库的账号
  password: 'root' // 连接数据库的密码
})

// 查询第一条匹配的记录
const first = sql => {
  return new Promise((resolve, reject) => {
    db.query(sql, (err, result, fields) => {
      if (err) reject(err)
      else resolve(result[0])
    })
  })
}

// 查询所有匹配的记录
const all = sql => {
  return new Promise((resolve, reject) => {
    db.query(sql, (err, result, fields) => {
      if (err) reject(err)
      else resolve(result)
    })
  })
}

module.exports = {
  first,
  all
}
```

- **/app.js**

> 引入**/utils/db.js**连接数据库，并获取查询方法(first, all)，之所有要在入口文件中导入是因为只需要在入口文件中导入一次，就可以把导入的查询方法传递给路由中

```js
var createError = require("http-errors");
var express = require("express");
var path = require("path");
var cookieParser = require("cookie-parser");
var logger = require("morgan");
const query = require('./utils/db'); // 导入数据库存查询方法

var app = express();

// view engine setup
app.set("views", path.join(__dirname, "views"));
app.set("view engine", "ejs");

app.use(logger("dev"));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, "public")));

// 引入路由(把数据库查询方法传递给路由)
app.use(require("./routes")(query));

// catch 404 and forward to error handler
app.use(function (req, res, next) {
  next(createError(404));
});

// error handler
app.use(function (err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get("env") === "development" ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render("error");
});

module.exports = app;
```

- **/routes/index.js**

> 通过路由入口文件将query继续向下传递

```js
var express = require("express");
var router = express.Router();

const mainRouter = query => {
  /* GET home page. */
  router.get("/", function (req, res, next) {
    res.render("index", { title: "Express" });
  });
  router.use(require('./weChat')(query))
  return router
}

module.exports = mainRouter
```

- **/routes/weChat.js**

> 通过包装函数获取到query，并把first传递给weChatController

```js
var express = require("express");
var router = express.Router();
var weChatController = require("../controller/weChatController");
var { getAccessToken } = require("../utils/tools");

// 素材上传功能所用到的类库
const FormData = require("form-data");
const concat = require("concat-stream");
const axios = require("axios");
const fs = require("fs");
const path = require("path");

const weChatRouter = ({ first, all }) => {
  router.get("/weChat", weChatController.weChat);
  router.post("/weChat", weChatController.weChatAction(first));
  // ... ...
  return router
};

module.exports = weChatRouter;

```

- **/controller/wechatController.js**

> 在用户订阅时，保存用户信息，在用户取消订阅时，将用户信息中的active字段修改一下

```js
//! 控制器，路由匹配成功后，用他来处理业务逻辑
const sha1 = require("sha1");
const xml2js = require("xml2js");
const sendMethod = require("../msgData");
const moment = require("moment");
const token = "ilmango";

const controller = {
  // ... ...
  weChatAction(first) {
    return (req, res) => {
      let postXmlData = [];
      // post传过来的数据都是数据流，不能直接通过req.body获取
      req.on("data", (chunk) => postXmlData.push(chunk));
      req.on("end", async () => {
        // 得到公众平台post发送过来的所有的xml内容 string
        let xmlStr = Buffer.concat(postXmlData).toString("utf-8");
        // 将xml转换成js对象以方便更好的去操作
        const xmlParser = new xml2js.Parser();
        // 解析为xml的json对象
        let { xml } = await xmlParser.parseStringPromise(xmlStr);
        // 公众平台的id号
        const toUserName = xml.ToUserName[0];
        // 发送给公众平台的微信在此平台的唯一id值
        const fromUserName = xml.FromUserName[0];
        // 消息类型 text image voice video music news
        let msgType = xml.MsgType[0];
        // 发送过来的消息内容
        let content = xml.Content ? xml.Content[0] : "";
        // 根据用户输入的数据来决定要返回什么内容，注意这里先判断用户发送的是什么内容，这里只有用户发送文件时才会进行响应
        if ("text" === msgType) {
          // ... ...
        } else if ("event" === msgType) {
          const event = xml.Event[0]; // 获取事件标识
          if ("subscribe" === event) {
            var time = moment().format("YYYY-MM-DD hh:mm:ss");
            // 根据fromUserName(openid: 用户的唯一标识)查询数据库中该用户的信息
            var sql = `select openid,active from wx_users where openid='${fromUserName}'`;
            // 这里使用了first，如果没有查询到数据则会返回undefined，如果查到则会返回一个对象
            var ret = await first(sql);
            // 如果为undefined则表示为一个新用户，直接插入数据库，如果不为undefined则表示为老用户(取消关注了)，更新数据库中的数据(更新mtime：再次关注的时间)
            if (!ret) {
              var sql = `insert into wx_users (openid,ctime,mtime) values ('${openid}','${time}','${time}')`;
              await first(sql);
            } else {
              if (ret.active === "0") {
                var sql = `update wx_users set active='1',mtime='${time}'`;
                await first(sql);
              }
            }
            res.send(
              sendMethod(
                "text",
                fromUserName,
                toUserName,
                "😘😘😘欢迎关注此公众平台,您将得到所有的可用的前端知识!😘😘😘\n回复\n1:实时新闻\n2:娱乐新闻\n3:科技与狠活"
              )
            );
          } else if ("unsubscribe" === event) {
            // 根据fromUserName把当前用户在数据表中修改一下状态 active='0'
            var sql = `update wx_users set active='0' where openid='${openid}'`;
            var ret = await first(sql);
            res.send("");
          } else if ("CLICK" === event) {
            const eventKey = xml.EventKey[0];
            if ("click001" === eventKey) {
              content = "视频教程";
            } else {
              content = "咨询小千";
            }
            res.send(sendMethod("text", fromUserName, toUserName, content));
          } else {
            res.send("");
          }
        }
      });
    };
  },
};

module.exports = controller;
```

## 场景二维码

> 为了满足用户渠道推广分析和用户帐号绑定等场景的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送,并得到场景值，解决关注时用户来源问题。
>
> **目前有2种类型的二维码：**
>
> - 临时二维码，是有过期时间的，最长可以设置为在二维码生成后的30天（即2592000秒）后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景
>
> - 永久二维码，是无过期时间的，但数量较少（目前为最多10万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景
>
> **获取场景二维码的步骤:**
>
> - 通过access_token获取ticket(凭据)
>
> - 通过ticket(凭据)换取二维码图片资源
>
> - 保存二维码图片资源到自己服务器中

```js
var express = require("express");
var router = express.Router();
var { getAccessToken } = require("../utils/tools");

const wechatRouter = ({ first, all }) => {
  // ... ...
  // 生成场景临时二维码
  router.get("/qr", async (req, res) => {
    let accessToken = await getAccessToken();
    // 1.用于换取ticket凭据，用来得到二维码
    var url = `https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=${accessToken}`;
    // action_name: "QR_SCENE"表示为临时的整型参数值，expire_seconds表示过期时间，action_info表示二维码详细信息
    // scene_id表示场景id，如果有人扫描该ticket生成的二维码并关注公众号，我们可以收到一个msgType为event的消息，他的eventKey就是由这里的scene_id组成的字符串
    const postData = { expire_seconds: 2592000, action_name: "QR_SCENE", action_info: { scene: { scene_id: 37 } } };
    let ret = await axios.post(url, postData);
    const { ticket } = ret.data;
    // 2.获取场景二维码的图片地址
    var url = `https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=${encodeURIComponent(ticket)}`;
    res.send(`<img src="${url}" />`);
  });
  // ... ...
  return router;
};

module.exports = wechatRouter;
```

> 当某个用户是通过另一个用户的场景二维码关注本公众号时，服务器会收到一个msgType为event的消息，事件类型为subscribe，但是和直接关注不同的是，这种关注事件会有额外的eventKey,这个eventKey值为qrscene_为前缀，后面为二维码的参数值(action_info)，示例：'qrscene_37'

```js
//! 控制器，路由匹配成功后，用他来处理业务逻辑
const sha1 = require("sha1");
const xml2js = require("xml2js");
const sendMethod = require("../msgData");
const moment = require("moment");
const token = "ilmango";

const controller = {
  // ... ...
  weChatAction(first) {
    return (req, res) => {
      let postXmlData = [];
      // post传过来的数据都是数据流，不能直接通过req.body获取
      req.on("data", (chunk) => postXmlData.push(chunk));
      req.on("end", async () => {
        // 得到公众平台post发送过来的所有的xml内容 string
        let xmlStr = Buffer.concat(postXmlData).toString("utf-8");
        // 将xml转换成js对象以方便更好的去操作
        const xmlParser = new xml2js.Parser();
        // 解析为xml的json对象
        let { xml } = await xmlParser.parseStringPromise(xmlStr);
        // 公众平台的id号
        const toUserName = xml.ToUserName[0];
        // 发送给公众平台的微信在此平台的唯一id值
        const fromUserName = xml.FromUserName[0];
        // 消息类型 text image voice video music news
        let msgType = xml.MsgType[0];
        // 发送过来的消息内容
        let content = xml.Content ? xml.Content[0] : "";
        // 根据用户输入的数据来决定要返回什么内容，注意这里先判断用户发送的是什么内容，这里只有用户发送文件时才会进行响应
        if ("text" === msgType) {
		  // ... ...
        } else if ("event" === msgType) {
          const event = xml.Event[0]; // 获取事件标识
          if ("subscribe" === event) {
            // 当用户通过场景二维码关注公众号时，会在用户关注公众号后，推送一条带参数的二维码扫描事件给开发者
            // 如果是直接通过搜索关注的，则EventKey没有值，如果是通过扫描二维码关注的，则EventKey有值
            // 值为qrscene_为前缀，后面为二维码的参数值(action_info)，示例：'qrscene_37'
            var qrSceneKey = xml.EventKey[0];
            // 把scene_id截取出来，并转换为数字，如果没有则为null
            let pid = qrSceneKey === "" ? null : Number(qrSceneKey.split("_")[1]);
            // 保存关注时间，或再次关注的时间
            var time = moment().format("YYYY-MM-DD hh:mm:ss");
            // 根据fromUserName(openid: 用户的唯一标识)查询数据库中该用户的信息
            var sql = `select openid,active from wx_users where openid='${fromUserName}'`;
            // 这里使用了first，如果没有查询到数据则会返回undefined，如果查到则会返回一个对象
            var ret = await first(sql);
            // 如果为undefined则表示为一个新用户，直接插入数据库，如果不为undefined则表示为老用户(取消关注了)，更新数据库中的数据(更新mtime：再次关注的时间)
            if (!ret) {
              // 如果是一个新用户，并且没有pid(表示是直接通过搜索关注的)，则直接插入数据库
              // 而如果是一个新用户，并且有pid(表示是通过扫描二维码关注的)，这样的话就需要根据pid查询数据库中的用户信息(该用户是谁邀请的)
              // 然后把该用户的id作为一级推荐人，并把该用户的一级推荐人作为二级推荐人，二级推荐人作为三级推荐人，然后插入数据库(最高三级推荐人，再多就违法了)
              // 在真实业务中，会根据分销人员的等级来分配好处，比如一级推荐人可以获得10%的佣金，二级推荐人可以获得5%的佣金，三级推荐人可以获得2%的佣金
              // 如果某个用户没有推荐人，则它可以获取所有的佣金
              if (!null) {
                var sql = `insert into wx_users (openid,ctime,mtime) values ('${openid}','${time}','${time}')`;
                await first(sql);
              } else {
                var sql = `select openid,level1,level2 from wx_users where id=${pid}`;
                var userinfo = await first(sql);
                var sql = `insert into wx_users (openid,ctime,mtime,level1,level2,level3) values ('${openid}','${time}','${time}','${userinfo.openid}','${userinfo.l1}','${userinfo.l2}')`;
                await first(sql);
              }
            } else {
              if (ret.active === "0") {
                var sql = `update wx_users set active='1',mtime='${time}'`;
                await first(sql);
              }
            }
            res.send(
              sendMethod(
                "text",
                fromUserName,
                toUserName,
                "😘😘😘欢迎关注此公众平台,您将得到所有的可用的前端知识!😘😘😘\n回复\n1:实时新闻\n2:娱乐新闻\n3:科技与狠活"
              )
            );
          } else if ("unsubscribe" === event) {
            // 根据openid把当前用户在数据表中修改一下状态 active='0'
            var sql = `update wx_users set active='0' where openid='${openid}'`;
            var ret = await first(sql);
            res.send("");
          } else if ("CLICK" === event) {
            const eventKey = xml.EventKey[0];
            if ("click001" === eventKey) {
              content = "视频教程";
            } else {
              content = "咨询小千";
            }
            res.send(sendMethod("text", fromUserName, toUserName, content));
          } else {
            res.send("");
          }
        }
      });
    };
  },
};

module.exports = controller;
```

## 网页授权

> 公众号后台可以通过设置授权域名，然后通过此域名生成相应的链接，分享到朋友圈，好友等，用户通过微信客户端来点击访问此链接，公众平台就可以获取用户基本信息，进而实现业务逻辑。
>
> 应用场景：问卷调查、 在线投票等

### 网页授权流程

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/fasdfadsafhgf.png" alt="fasdfadsafhgf" style="zoom:67%;" />

### 设置微信授权域名

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/jytjrtyj.png" alt="jytjrtyj" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/nyrthfghfgd.png" alt="nyrthfghfgd" style="zoom:67%;" />

### 微信授权代码实现

> 实现网页授权，公众平台给我们提供2种权限(关于网页授权的两种scope的区别说明)：
>
> 1. 以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）
>
> 2. 以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。

**第一步：用户同意授权，获取code**

> 在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（已认证服务号，默认拥有 scope 参数中的snsapi_base和snsapi_userinfo 权限），引导关注者打开如下页面：

> scope为snsapi_base：
>
> https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&response_type=code&scope=snsapi_base&state=123#wechat_redirect
>
> **scope为snsapi_userinfo：**
>
> https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect

| 参数             | 是否必须 | 说明                                                         |
| :--------------- | :------- | ------------------------------------------------------------ |
| appid            | 是       | 公众号的唯一标识                                             |
| redirect_uri     | 是       | 授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理 |
| response_type    | 是       | 返回类型，请填写code                                         |
| scope            | 是       | 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过 openid 拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） |
| state            | 否       | 重定向后会带上 state 参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节 |
| #wechat_redirect | 是       | 无论直接打开还是做页面302重定向时候，必须带此参数            |
| forcePopup       | 否       | 强制此次授权需要用户弹窗确认；默认为false；需要注意的是，若用户命中了特殊场景下的静默授权逻辑，则此参数不生效 |

**第二步：通过code换取网页授权access_token和openid**

如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&state=STATE，code作为换取access_token的票据，每次用户授权带上的 code 将不一样，code只能使用一次，5分钟未被使用自动过期

> 关于网页授权access_token和普通access_token的区别
>
> 1. 微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息
> 2. 其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用

```js
const router = require("express").Router();
const { getAccessToken } = require("../utils/tools");

const appid = "wxae077dbd6d0b42b8";
const secret = "12692272e71906eacbdde9e3023e3062";

const wechatRouter = ({ first, all }) => {
  // ... ...
  // 生成授权网址
  router.get("/createAuthUrl_base", async (req, res) => {
    // 授权后重定向的网址，这里必须使用uri编码转义一下特殊字符
    let redirect_uri = encodeURIComponent(req.query.redirect_uri);
    var url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&redirect_uri=${redirect_uri}&response_type=code&scope=snsapi_base&state=10000#wechat_redirect`;
    res.send(url);
  });

  // 授权后重定向到的网址
  router.get("/vote", async (req, res) => {
    // 在query中获取到code值
    let { code } = req.query;
    // 通过code值去向公众平台要用户信息(openid和access_token)
    let url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${appid}&secret=${secret}&code=${code}&grant_type=authorization_code`;
    let ret = await axios.get(url);
    res.send(ret.data.openid + "");
  });

  return router;
};

module.exports = wechatRouter;
```

**拉取用户信息(需scope为 snsapi_userinfo)**

> 获取用户信息，并传递给前端页面，这里使用ssr进行渲染，因此需要安装模板引擎
>
> 并且为了保持用户数据(避免重复请求)，所以我们使用session来完成
>
> ```js
> npm install express-art-template --save
> npm install cookie-session --save
> ```

- **/app.js**

> 配置art-template和cookie-session

```js
var session = require("cookie-session"); // 导入cookie-session模块

// 遇到art后缀的文件使用art-template进行解析
app.engine("art", require("express-art-template"));
// res.render渲染的模板默认存储位置
app.set("views", path.join(__dirname, "views"));
// res.render渲染的模板默认的后缀名
app.set("view engine", "art");
// session配置
app.use(
  session({
    name: "session_id",
    secret: "tRyw6vU!iMnzHD4x8jTxCXS7RjGiPhq31exwD2X0O$u7vrBULT$&JsgGUW&EE$4jbBFQAArPdmW18WA4c1kOe8*4NCYbZ2ZErW^",
  })
);
```

- **/routes/weChat.js**

> 生成授权地址，用户同意授权后，即可在重定向地址中的query中得到code，然后就可以拿着code去获取用户access-token，最后拿着用户access-token去得到用户信息

```js
const router = require("express").Router();
const { getAccessToken } = require("../utils/tools");

const appid = "wxae077dbd6d0b42b8";
const secret = "12692272e71906eacbdde9e3023e3062";

const wechatRouter = ({ first, all }) => {
  // ... ...
  // 生成授权网址
  router.get("/createAuthUrl_base", async (req, res) => {
    // 授权后重定向的网址，这里必须使用uri编码转义一下特殊字符
    let redirect_uri = encodeURIComponent(req.query.redirect_uri);
    var url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&redirect_uri=${redirect_uri}&response_type=code&scope=snsapi_base&state=10000#wechat_redirect`;
    res.send(url);
  });

  // 授权后重定向到的网址
  router.get("/vote_userinfo", async (req, res) => {
    // 通过code值去向公众平台要用户信息(openid和access_token)
    let { code } = req.query;
    // 如果没有session数据时才去重新请求用户数据
    if (!req.session.openid) {
      var url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${appid}&secret=${secret}&code=${code}&grant_type=authorization_code`;
      var ret = await axios.get(url);
      let { openid, access_token } = ret.data;

      // 如果授权是userinfo模式，则可以通过请求到的用户access_token来拉取用户信息
      var url = `https://api.weixin.qq.com/sns/userinfo?access_token=${access_token}&openid=${openid}&lang=zh_CN`;
      var ret = await axios.get(url);
      let { nickname, headimgurl } = ret.data; // 解构用户名和头像url

      // 得到的数据，存储在session中，用于当前会话信息的保持，session是用于在服务器端渲染时，保持用户状态的方案
      req.session.openid = openid;
      req.session.nickname = nickname;
      req.session.headimgurl = headimgurl;
    }

    // 参数1：指定views目录下面的文件
    // 参数2：给模板赋的值（通过小胡子请求获取）
    res.render("vote.art", {
      openid: req.session.openid,
      nickname: req.session.nickname,
      headimgurl: req.session.headimgurl,
    });
  });
  return router;
};

module.exports = wechatRouter;
```

- **/views/vote.art**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- 移动端开发时，此声明一定要有 -->
  <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>投票一下</title>
</head>

<body>
  <h3><span id="nickname">{{nickname}}</span> ---- {{openid}}</h3>
  <img src="{{headimgurl}}" alt="">
</body>

</html>
```

## 微信JS-SDK

### 什么是JS-SDK

> JS-SDK就是微信帮助我们完成的JS一个工具的封装，直接调用这些接口就可以完成相应的功能。JS-SDK必须在微信环境下才可以用，不能在浏览器直接使用。通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。还可以使用它自定义分享的链接(此链接必须与公众后台有效域名一致)
>
> **步骤：**
>
> - 平台绑定授权域名
>
> - 引入公众平台jssdk的js文件
>
> - 根据官方签名算法编写出对应的签名字符串
>
> - 设置前台script中的config接口配置注入权限验证
>
> - 通过前台script中的接口提供的ready(成功)/error(失败)方法处理

### JS-SDK使用流程

**步骤一：绑定域名**

> 与配置网页授权域名类似，这里的域名不需要写协议，例如：r7b4y4.natappfree.cc

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/Snipaste_2022-10-26_08-34-31.png" alt="Snipaste_2022-10-26_08-34-31" style="zoom:67%;" />

**步骤二：引入 JS 文件**

在需要调用 JS 接口的页面引入如下 JS 文件（支持https，详见官网）：

http://res.wx.qq.com/open/js/jweixin-1.6.0.js

**步骤三: 根据官方签名算法编写出对应的签名字符串**

- **/routes/weChat.js**

```js
var express = require("express");
var router = express.Router();
var { getAccessToken } = require("../utils/tools");
var sha1 = require("sha1");


// 测试号信息，用于请求微信公众平台的凭据
const appid = "wxef51ed34ca2cbf3c";
const secret = "8ff5ba423003a7f2a3a30b7aeaa01e02";

const weChatRouter = ({ first, all }) => {
  // ... ...
  // 在服务器端生成jssdk所需要的config配置信息
  router.post("/jsSdkConfig", async (req, res) => {
    // 获取access_token
    let accessToken = await getAccessToken();
    // 获取jsapi_ticket，jsapi_ticket是公众号用于调用微信 JS 接口的临时票据
    // 正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取
    var url = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=${accessToken}&type=jsapi`;
    var ret = await axios.get(url);
    const { ticket } = ret.data;
    // 生成时间戳
    const timestamp = Math.floor(Date.now() / 1000);
    // 要把前端传来的url进行解码，因为前端传来的url是经过编码的
    // 注意：url必须是步骤一中绑定的域名，否则会验证失败
    var url = decodeURIComponent(req.body.url);
    // 生成签名的随机字符串
    const noncestr = "Wm3WZYTPz0wzccnW";
    // 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
    // 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用 URL 键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1
    // 这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义
    const signature = sha1(`jsapi_ticket=${ticket}&noncestr=${noncestr}&timestamp=${timestamp}&url=${url}`);

    res.send({
      appid,
      timestamp,
      noncestr,
      signature,
    });
  });

  return router;
};

module.exports = weChatRouter;
```

**步骤四：通过 config 接口注入权限验证配置**

- **/views/template.art**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="http://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script> // 引入js-sdk
</head>

<body>
  <script>
    fetch('/jsSdkConfig', {
      method: 'post',
      // 由于url中有&符号，所以需要转义，防止有歧义，后端解析错误
      // url=http://r7b4y4.natappfree.cc/share?code=021YaZ00011cOO12Vr300Mh3kD4YaZ0L&state=10000
      body: `url=${encodeURIComponent(location.href)}`,
      headers: {
        'content-type': 'application/x-www-form-urlencoded' // 指定body数据为url格式(a=b&c=d)
      }
    }).then(ret => ret.json()).then(({
      appid,
      timestamp,
      noncestr,
      signature
    }) => {
      wx.config({
        debug: false,
        appId: appid, // 必填，公众号的唯一标识
        timestamp: timestamp, // 必填，生成签名的时间戳
        nonceStr: noncestr, // 必填，生成签名的随机串
        signature,// 必填，签名
        jsApiList: [] // 必填，需要使用的 JS 接口列表(就是对应的wx.方法名称)
      });
    })

    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作
    // 所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行
    // 对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中
    wx.ready(function () {});
    // config信息验证失败会执行 error 函数，如签名过期导致验证失败，具体错误信息可以打开 config 的debug模式查看
    // 也可以在返回的 res 参数中查看，对于 SPA 可以在这里更新签名
    wx.error(function(res) {});
  </script>
</body>

</html>
```

### 砍价案例

> 这个案例最难的部分就是考虑如何把你的openid和给你砍价的人的openid传进同一个页面中。解决方法如下：
>
> - 用户先进入share页面，但是这里的不是直接进入share页面，而是通过授权网址，通过授权后重定向进share页面
> - 这样就可以获取到用户的openid，这里就通过ssr把页面渲染出来，并把openid传给页面
> - share页面中配置了js-sdk的自定义分享消息，这个消息的url会指向授权页面，并且传递的state为openid
> - 该授权页面的重定向地址是bargain页面，这个页面经过授权后就可以获取到砍价用户的openid
> - 这样我们就可以同时获取到两者的openid

- **/routes/weChat.js**

```js
var express = require("express");
var router = express.Router();
var { getAccessToken } = require("../utils/tools");
var sha1 = require("sha1");

// 测试号信息，用于请求微信公众平台的凭据
const appid = "wxef51ed34ca2cbf3c";
const secret = "8ff5ba423003a7f2a3a30b7aeaa01e02";

const weChatRouter = ({ first, all }) => {
  // ... ...
  // 生成授权网址
  router.get("/createAuthUrl", async (req, res) => {
    // 授权后重定向的网址，这里必须使用uri编码转义一下特殊字符
    let redirect_uri = encodeURIComponent(req.query.redirect_uri) || "http://www.baidu.com";
    let state = req.query.state || "STATE";
    var url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&redirect_uri=${redirect_uri}&response_type=code&scope=snsapi_base&state=${state}#wechat_redirect`;
    res.send(url);
  });

  // 在服务器端生成jssdk所需要的config配置信息
  router.post("/jsSdkConfig", async (req, res) => {
    // 获取access_token
    let accessToken = await getAccessToken();
    // 获取jsapi_ticket，jsapi_ticket是公众号用于调用微信 JS 接口的临时票据
    // 正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取
    var url = `https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=${accessToken}&type=jsapi`;
    var ret = await axios.get(url);
    const { ticket } = ret.data;
    // 生成时间戳
    const timestamp = Math.floor(Date.now() / 1000);
    // 要把前端传来的url进行解码，因为前端传来的url是经过编码的
    var url = decodeURIComponent(req.body.url);
    // 生成签名的随机字符串
    const noncestr = "Wm3WZYTPz0wzccnW";
    // 参与签名的字段包括noncestr（随机字符串）, 有效的jsapi_ticket, timestamp（时间戳）, url（当前网页的URL，不包含#及其后面部分）
    // 对所有待签名参数按照字段名的ASCII 码从小到大排序（字典序）后，使用 URL 键值对的格式（即key1=value1&key2=value2…）拼接成字符串string1
    // 这里需要注意的是所有参数名均为小写字符。对string1作sha1加密，字段名和字段值都采用原始值，不进行URL 转义
    const signature = sha1(`jsapi_ticket=${ticket}&noncestr=${noncestr}&timestamp=${timestamp}&url=${url}`);

    res.send({
      appid,
      timestamp,
      noncestr,
      signature,
    });
  });

  // 分享页面
  router.get("/share", async (req, res) => {
    // 网页授权，得到访问者的openid
    let { code } = req.query;
    if (!req.session.openid) {
      var url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${appid}&secret=${secret}&code=${code}&grant_type=authorization_code`;
      var ret = await axios.get(url);
      let { openid } = ret.data;
      req.session.openid = openid; // 存储openid
    }
    res.render("share", {
      openid: req.session.openid,
    });
  });

  router.get("/bargain", async (req, res) => {
    // 网页授权，得到访问者的openid
    let { code } = req.query;
    if (!req.session.openid) {
      var url = `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${appid}&secret=${secret}&code=${code}&grant_type=authorization_code`;
      var ret = await axios.get(url);
      let { openid } = ret.data;
      req.session.openid = openid; // 存储openid
    }
    res.render("bargain", {
      targetOpenid: req.query.state,
      openid: req.session.openid,
    });
  });

  return router;
};

module.exports = weChatRouter;
```

- **/views/share.art**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="http://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
</head>

<body>
  <h3>自定义分享页面 -- 砍价 -- {{openid}}</h3>
  <img id="img" src="" alt="">
  <button onclick="selectPic()">选择图片</button>
  <script>
    var openid = '{{openid}}';

    fetch('/jsSdkConfig', {
      method: 'post',
      // 由于url中有&符号，所以需要转义，防止有歧义，后端解析错误
      // url=http://r7b4y4.natappfree.cc/share?code=021YaZ00011cOO12Vr300Mh3kD4YaZ0L&state=10000
      body: `url=${encodeURIComponent(location.href)}`,
      headers: {
        'content-type': 'application/x-www-form-urlencoded' // 指定body数据为url格式(a=b&c=d)
      }
    }).then(ret => ret.json()).then(({
      appid,
      timestamp,
      noncestr,
      signature
    }) => {
      wx.config({
        debug: false,
        appId: appid, // 必填，公众号的唯一标识
        timestamp: timestamp, // 必填，生成签名的时间戳
        nonceStr: noncestr, // 必填，生成签名的随机串
        signature,// 必填，签名
        // 授权权限列表,就是对应的wx.方法名称
        jsApiList: [
          'updateAppMessageShareData',
          'updateTimelineShareData',
          'chooseImage'
        ] // 必填，需要使用的 JS 接口列表
      });
    })

    // config信息验证后会执行 ready 方法，所有接口调用都必须在 config 接口获得结果之后，config是一个客户端的异步操作
    // 所以如果需要在页面加载时就调用相关接口，则须把相关接口放在 ready 函数中调用来确保正确执行
    // 对于用户触发时才调用的接口，则可以直接调用，不需要放在 ready 函数中
    wx.ready(function () {
      // 自定义分享消息(分享给朋友)
      wx.updateAppMessageShareData({
        title: '多喝这道冬瓜排骨汤', // 分享标题
        desc: '一场秋雨过后，气温骤降，这就是所谓的“一场秋雨，一场寒”', // 分享描述
        link: getRedirectUrl(), // 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致
        imgUrl: 'https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/6d79e9d09d5d4748868c106511f9fd56~noop.image?_iz=58558&from=article.pc_detail&x-expires=1667272473&x-signature=E3XidUFA1wHcRC%2F31TQ6eZOlHHw%3D', // 分享图标
        success: function () { }
      })

      // 自定义分享消息(朋友圈)
      wx.updateTimelineShareData({
        title: '多喝这道冬瓜排骨汤', // 分享标题
        link: getRedirectUrl(), // 分享链接，该链接域名或路径必须与当前页面对应的公众号 JS 安全域名一致
        imgUrl: 'https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/6d79e9d09d5d4748868c106511f9fd56~noop.image?_iz=58558&from=article.pc_detail&x-expires=1667272473&x-signature=E3XidUFA1wHcRC%2F31TQ6eZOlHHw%3D', // 分享图标
        success: function () { }
      })
    });

    // config信息验证失败会执行 error 函数，如签名过期导致验证失败，具体错误信息可以打开 config 的debug模式查看
    // 也可以在返回的 res 参数中查看，对于 SPA 可以在这里更新签名
    wx.error(function (res) { });

    async function getRedirectUrl() {
      let ret = await fetch(`/createAuthUrl?redirect_uri=${encodeURIComponent('http://r7b4y4.natappfree.cc/bargain')}&state=${openid}`);
      let data = await ret.text()
      console.log(data)
      return data
    }

    function selectPic() {
      wx.chooseImage({
        count: 1, // 可选择多少张图片，默认9
        sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有
        sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有
        success: function (res) {
          // 返回选定照片的本地 ID 列表，localId可以作为 img 标签的 src 属性显示图片
          var localIds = res.localIds;
          document.getElementById('img').src = localIds
        }
      });
    }
  </script>
</body>

</html>
```

- **/views/bargain.art**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- 移动端开发时，此声明一定要有 -->
  <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>投票一下</title>
</head>

<body>
  // 同时获取你的openid和要给你砍价的人的openid
  {{targetOpenid}} <br\> {{openid}}
</body>

</html>
```

