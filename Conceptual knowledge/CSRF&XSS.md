# CSRF

> CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF
>
> CSRF可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账…造成的问题包括：个人隐私泄露以及财产安全。

## CSRF攻击原理

![0350aa6a64b56f5d992c29517c8cc32a](https://raw.githubusercontent.com/ilmangoi/imgRepo/main/img/0350aa6a64b56f5d992c29517c8cc32a.png)

从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：

1. 登录受信任网站A，并在本地生成Cookie

2. 在不登出A的情况下，访问危险网站B

因此只要不满足以上两个条件中的一个，就不会受到CSRF的攻击。但是有的时候并不能保证以下情况不会发生：

1. 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站

2. 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了…）

3. 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站

## 攻击案例

银行网站A，它以GET请求来完成银行转账的操作，如：`http://www.mybank.com/Transfer.php?toBankId=11&money=1000`

而在危险网站B中，它里面有一段HTML的代码如下，由于图片src是主动访问，因此只要访问该网站，它就会使用你的cookie请求该后端接口(身份伪造)：

```html
<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
```

首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块，为什么会这样呢？

在访问危险网站B的之前，你已经登录了银行网站A，而B中的 `<img>` 以GET的方式请求第三方资源（这里的第三方就是指银行网站，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“`http://www.mybank.com/Transfer.php?toBankId=11&money=1000`”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作

## 防御方案(基于加密的令牌模式)

基于加密的令牌模式利用了加密，而不是对比的方式来核实令牌有效性。它最适合**不想在服务器端中维持任何状态**的应用程序。

建议服务器使用仅在服务器上可用的唯一密钥生成包含用户会话ID和时间戳的令牌。这个令牌返回给客户端，并嵌入到表单的隐藏字段中（再请求头或者请求参数中）。在接收到这个请求时，服务器读取并使用（生成此令牌的）密钥解密该令牌的值。

如果令牌不能被解密，则这表明有入侵企图（应该阻止并记录到日志，用于调试或事件响应的目的）。一旦成功解密，则令牌中的用户会话ID和时间戳是有效的。会话ID和当前登录用户相比较，时间戳和当前时间比较，以验证其并未超出令牌的有效时间。如果会话ID匹配，且时间戳在有效时间内，则请求通过。

# XSS

> XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

## XSS攻击案例

比如在某网站的留言板中。我们知道留言板通常的任务就是把用户留言的内容展示出来。正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行

```text
<script>alert(“hey!you are attacked”)</script>
```

那么留言板界面的网页代码就会变成形如以下，当用户进入该页面后就会弹出一个弹出框，显示你被攻击了！！！

```html
<html>
<head>
  <title>留言板</title>
</head>
<body>
  <script>
    alert(“hey!you are attacked”)
  </script>   
</body>
</html>
```

## XSS的危害

### **窃取网页浏览中的cookie值**

在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户

如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie

试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施，如Http-Only保证cookie不能通过脚本获取到）

### **劫持流量实现恶意跳转**

```js
<script>window.location.href="http://www.baidu.com";</script>
```

那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博

## 绕过XSS防御

### **大小写绕过**

这个绕过方式的出现是因为网站仅仅只过滤了<script>标签，而没有考虑标签中的大小写并不影响浏览器的解释所致，比如如下代码：

```html
<sCript>alert("hey!")</scRipt>
```

### **利用过滤后返回语句再次构成攻击语句来绕过**

```html
<sCri<script>pt>alert("hey!")</scRi</script>pt>
```

### 其它标签插入代码

> 指定的图片地址根本不存在也就是一定会发生错误，这时候onerror里面的代码自然就得到了执行

```html
<img src='w.123' onerror='alert("hey!")'>
```

以下是一些可插入代码的标签，当用户鼠标在这个块上面时即可运行（可以配合width等参数将div覆盖页面，鼠标不划过都不行）：

```html
<a onmousemove=’do something here’> 
<div onmouseover=‘do something here’> 
```

### **编码脚本代码绕过关键字过滤**

> 有的时候，服务器往往会对代码中的关键字（如alert）进行过滤，这个时候我们可以尝试将关键字进行编码后再插入，不过直接显示编码是不能被浏览器执行的，我们可以用另一个语句eval（）来实现，eval()会将编码过的语句解码后再执行
>
> 例如alert(1)编码过后就是：`\u0061\u006c\u0065\u0072\u0074(1)`

```html
<script>
  eval(\u0061\u006c\u0065\u0072\u0074(1))
</script>
```