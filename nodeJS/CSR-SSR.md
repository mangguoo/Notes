# CSR SSR优缺点

> - load（Onload Event），它代表页面中依赖的所有资源加载完的事件
> - DCL（DOMContentLoaded），DOM解析完毕
> - FP（First Paint），表示渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发
> - FCP（First Contentful Paint），表示渲染出第一个内容，这里的“内容”可以是文本、图片、canvas
> - FMP（First Meaningful Paint），首次渲染有意义的内容的时间，“有意义”没有一个标准的定义，FMP的计算方法也很复杂
> - LCP（largest contentful Paint），最大内容渲染时间

- CSR优点：
  - FP最快，客户端体验较好，因为在数据没有更新之前，页面框架和元素是可以再dom生成的
  - FP：仅有一个div根节点。以vue为例，div#app注册一个空的div
  - FCP：包含页面的基本框架，但没有数据内容。以vue为例，每个template的div框架，对于vue生命周期的mounted
  - FMP：包含页面所有元素及数据，以vue为例，通过接口更新到页面的数据后完整的页面展示，对应生命周期的updated
- CSR缺点：
  - 不利于SEO-爬虫数据，整体加载完速度慢
- SSR优点
  - 返回的页面全部是HTML结构，包含所有需要呈现的数据，利于搜索引擎或者爬虫的数据抓取
  - 目前使用的MVVM架构，大多都是前后端分离，数据都是动态生成，不利于SEO优化。而SSR利于首屏渲染，首屏的加载来自于服务器，不会依赖服务端的接口请求再数据请求
- SSR缺点
  - 性能依赖服务器，前端界面开发可操作性不高
- 两者的不同之处
  - 服务端渲染的优势在于首屏渲染速度快，简单来讲他不需要来回往返于客户端和服务端。但是其性能等众多因素会影响用户体验。比如说，网速，在线活跃人数，服务器的物理位置等等
  - 而客户端和服务端渲染相反，因为多次和服务器的交互导致首屏加载速度慢。但是一旦这都些请求都加载完成之后，用户和页面之间的交互时用户的体验就会好很多

# 网页优化方案

1. 优化首屏加载，减少白屏时间，提升加载性能

- 首屏所有图片懒加载，啥时候用啥时候加载
- 因为引入css，js都需要加载时间，所以首屏的css 要独立存放，所有的css和js要压缩，优先加载首屏的css和js，其余不重要的异步加载
- js可以用async或defer属性做到懒加载，js和css都可以使用lazyLoad方法

2. 加速或者减少HTTP请求损耗

> - 使用 CDN 加载公共库
>
> - 使用强缓存和协商缓存
> - 使用域名收敛
> - 小图片可以使用Base64代替
> - 使用Get请求代替Post请求
> - 设置Access-Control-Max-Age减少预检请求
> - 页面跳转其他域名或请求其他域名资源的时候使用浏览器的prefetch预解析等
> - 扩大带宽加速网络，减少HTTP请求（首屏使用 SSR，减少请求量）

- CDN：将程序上传到服务器，CDN会拉取到所有的服务器站点客户访问时会自动选择近的服务器访问，例如Jquery库就放到了CDN上面，我们使用的时候就不需要自己上传，直接使用人家存好的就可以

- 强缓存：HTTP头上有Expires和cache-control。这个是强制设置缓存，设置缓存时长

- 协商缓存：也是在HTTP头上有一个last-modified。会存程序的修改时间，每次请求都会带着，如果修改了就会重新请求

- 域名收敛：就是将静态资源放在一个域名下减少DNS解析的开销，这主要是为了适应移动端的发展需求。通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的

- 域名发散是pc端为了利用浏览器的多线程并行下载能力，而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加 DNS的解析开销

- DNS预解析：浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验

 ``` jsx
 <link rel="dns-prefetch" href="//g.alicdn.com" />
 <link rel="dns-prefetch" href="//img.alicdn.com" />
 <link rel="dns-prefetch" href="//tce.alicdn.com" />
 ```

- 图片可以先试用小图片放大，当图片加载完毕在替换，也可以将图片的Base64直接放在页面中

- 使用Get代替Post请求，因为Get请求会自动产生缓存，而且Get比Post少发送一次请求

3. 延迟加载

- 非重要的库、非首屏图片延迟加载，SPA 组件懒加载

4. 减少请求内容的体积

- 开启服务器Gip压缩，JS,CSS问价压缩合并，减少cookoe大小，SSR直接渲染

5. 优化关键渲染路径，就可能减少阻塞渲染的JS和CSS

6. 优化用户体验

- 白屏使用时间加载进度条，loading图，骨架屏代替