### 高阶组件(HOC)

> 高阶组件(Higher-Order Components)就是一个函数，传给它一个组件，它返回一个新的组件。高阶组件就相当于手机壳，通过包装组件，增强组件功能。
>
> 高阶组件常见作用：
>
> - 进行权限控制
>
> - 路由限制
>
> - 访问统计
>
> - 统一布局

#### 定义高阶组件

- **类组件**

```jsx
import React from 'react'
import _ from 'lodash'

const withLayout = Cmp => {
  class Layout extends React.Component {
    render() {
      let props = _.cloneDeep(this.props)
      props.phone = 'aaaaaa'

      return <div>
        <h3 style={{ color: 'red' }}>我是一个高阶组件</h3>
        <hr /> 
        <Cmp {...props} />
      </div>
    }
  }
  return Layout
}

export default withLayout
```

- **函数组件**

```jsx
import React from 'react'
import _ from 'lodash'

const withLayout = Cmp => props => {
  let myprops = _.cloneDeep(props)
  myprops.phone = 'bbbb'
  return (
    <div>
      <h3 style={{ color: 'blue' }}>我是一个高阶组件</h3>
      <hr />
      <Cmp {...myprops} />
    </div>
  )
}

export default withLayout
```

- **使用高阶组件**

```jsx
import React, { Component } from 'react'
import withLayout from '../../hoc/withLayout'

class Child extends Component {
  render() {
    return (
      <div>
        <h3>
          我是Child组件 -- {this.props.title} -- {this.props.phone}
        </h3>
      </div>
    )
  }
}

export default withLayout(Child)
```

#### 使用装饰器调用

> 装饰器使用**@函数名**写法，对类进行装饰，目前在js中还是提案，使用需要配置相关兼容代码库。react脚手架创建的项目默认是不支持装饰器，需要手动安装相关模块和添加配置文件。

- **安装相关模块**

```js
// 这两个包用于重写wepack配置
npm install -D customize-cra react-app-rewired
// 这个包用于提供装饰器特性
npm install -D @babel/plugin-proposal-decorators
```

- **修改package.json文件中scripts命令**

```json
"scripts": {
   "start": "react-app-rewired start",
   "build": "react-app-rewired build",
   "test": "react-scripts test",
   "eject": "react-scripts eject"
}
```

- **在项目根目录中添加config-overrides.js配置文件**

```js
const { resolve } = require('path')
const { addDecoratorsLegacy, override } = require('customize-cra')

// 增强自定义给webpack添加相关配置，config就是已有的webpack配置
const custom = () => config => {
  config.resolve.alias['@'] = resolve('./src')
  return config
}

module.exports = override(addDecoratorsLegacy(), custom())
```

- **在项目根目录下创建 .babelrc 并写入以下内容**

```json
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    [
      "@babel/plugin-proposal-decorators",
      {
        "legacy": true
      }
    ]
  ]
}

```



- **使用装饰器**

```jsx
import React, { Component } from 'react'
import withLayout from '../../hoc/withLayout'

@withLayout
class Child extends Component {
  render() {
    return (
      <div>
        <h3>
          我是Child组件 -- {this.props.title} -- {this.props.phone}
        </h3>
      </div>
    )
  }
}

export default Child
```

### 装饰器

> 装饰器是用来装饰类的，可以增强类，在不修改类的内部的源码的同时，增强它的能力(属性或方法)

**不传参**

```js
装饰函数，在装饰时它没有写小括号
target它就是当前你装饰的类
const handle = target => {
  // 定义一个静态方法，不是成员方法,无法通过实例来调用
  target.run = () => console.log('run')
  Demo.run()

  // 成员属性
  target.prototype.$http = 'http请求对象'

  // 成员方法
  target.prototype.run = function () {
    console.log('run@')
  }
}
@handle
class Demo {}
const d = new Demo()
console.log(d.$http);
d.run()
```

**传参**

```js
// 如果装饰器传入了参数，则定义装饰器函数时一定要返回一个新函数
const handle = msg => target => {
  // 成员方法
  target.prototype.run = function () {
    console.log('run@ ==', msg)
  }
}

@handle('你好装饰器')
class Demo {}
const d = new Demo()
d.run()
```

#### 装饰成员方法

```js
const handle = name => (target, key, description) => {
  // 原对象中的方法
  // 这里的oldFn是存在this指向问题的，在这里它的this一定是指向undefined
  let oldFn = description.value

  description.value = function (...arg) {
    console.log('我是增强后的方法')
    // 可以在这里解决this指向问题，因为这个方法就是被装饰后的方法，它是会重新赋给Demo类的，因此它的this指向是正确的，也就是Demo类，在这个方法中重新绑定oldFn的this就可以解决this指向问题
    oldFn.apply(this, arg)
  }
}

class Demo {
  username = '李四'

  @handle('张三')
  push(arg) {
    console.log('demo中的push方法', arg, this.username)
  }
}
const d = new Demo()
d.push('111')
```

#### 装饰成员属性

```js
// 成员属性不能重置值，因为装饰器实际是先于成员属性赋值语句执行的(  @handle('新名称');username = 'abc')，这就导致就是重置了成员属性的值，也会被重新改回来，但可以修改属性描述(definProperty)
// 但是在装饰成员属性时，可以动态的来添加别的成员属性或方法
const handle = name => (target, key, description) => {
  target.name = name

  target.fn = function () {
    console.log('fn')
  }
}

class Demo {
  @handle('新名称')
  username = 'abc'
}

const d = new Demo()
console.log(d.username)
console.log(d.name)
d.fn()
```

#### 装饰器调用高阶组件

```jsx
import React, { Component } from 'react'
import withLayout from '../hoc/withLayout'

const fn1 = target => {
  console.log(111)
}
const fn2 = target => {
  console.log(222)
}
// 多个装饰器时执行的顺序为 从下向上，从右向左
@fn1 @fn2 @withLayout
class Child extends Component {
  render() {
    return (
      <div>
        <div>child组件</div>
      </div>
    )
  }
}

export default Child
```

```jsx
/src/hoc/widthLayout.js
import React, { Component } from 'react';

export default Cmp => class extends Component {
  render() {
    return (
      <div>
        <h3>我是头部</h3>
        <hr />
        <Cmp {...this.props} />
      </div>
    );
  }
}
```

### 高阶组件反向继承

> 通过创建新组件继承自原始组件, 把原始组件作为父组件。作用：可以渲染劫持或是操作state数据。

**反向继承**【依赖注入、控制反转】

> 反射继承其实就是把父类与子类的调用顺序反转了一下，原本是子类先调用，然后在子类构造函数中使用super来调用父类构造方法，而现在这个过程反过来了，先调用父类，然后把父类构造出来的实例传递给子类。

```js
class Parent {
  constructor() {
    console.log('parent')
  }
}
class Child {
  constructor(parent) {
    const p = new Parent()
    console.log(111,parent)
  }
}
const parent = new Parent()
const c = new Child(parent)
```

**应用**

> Child组件，可以理解为是第3方组件，但是这个组件它功能可能不全，需要增强，现在要加强Child组件，给Child组件增加插槽功能，要给他增加插槽，就要先获取this.props.children，也就是说必需要先获取到Child组件的实例(父组件实例)，这时候就要用到反向继承了。

```jsx
/src/app.jsx
import React, { Component } from 'react'
import Child from './components/Child'

class App extends Component {
  render() {
    return (
      <div>
        <Child>你好世界</Child>
      </div>
    )
  }
}

export default App
```

```jsx
/src/hoc/widthCmp.js
import React, { Component } from 'react';

// 高阶组件的反向继承，用来扩展原组件中的页面结构或方法
export default Cmp => {
  return class extends Cmp {
    render() {
      // this.props.children是"你好世界"
      let ele = React.cloneElement(super.render().props.children, {}, this.props.children)
      return (
        <div>
          <h3>{this.state.id}</h3>
          {ele}
        </div>
      );
    }
  }
}
```

```jsx
/src/components/Child/index.jsx
import React, { Component } from 'react'
import withCmp from '../hoc/withCmp'

@withCmp
class Child extends Component {
  state = {
    id: 1
  }
  render() {
    return (
      <div>
        <button></button>
      </div>
    )
  }
}

export default Child
```

### memoization(计算属性/记忆组件)

> 类似于vue中的computed，用于计算所用，在类组件中，需要安装，在函数组件中它内置。此方法是一个性能优化的方案，可以不用，但是如果有计算且多次调用，则建议使用，因为它与方法最大的区别就是依赖项不变的话，他会进行缓存，不会重复计算。

```js
# 安装
npm i -S memoize-one
```

```js
# 引入
import memoizeOne from 'memoize-one'

# 使用
// n1和n2参数就是它的依赖项，只要它的依赖项没有变化，则第2次后调用都为缓存中读取
sum = memizeOne((n1, n2) => {
    console.log('memizeOne') // 只会打印一次
    return n1 + n2
})

# 调用
render() {
  let { n1, n2 } = this.state
  return (
    <div>
      <h3>{this.sum(n1, n2)}</h3>
      <h3>{this.sum(n1, n2)}</h3>
      <h3>{this.sum(n1, n2)}</h3>
    </div>
  )
}
```

### Portals

> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。

```jsx
import React, { Component } from 'react'
import { createPortal } from 'react-dom'

const createDialog = () => {
  const el = document.createElement('div')
  el.id = 'dialog'
  el.style.cssText = `  
      position: absolute;
      top: 0;
      width: 100%;
      min-height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 30px;
      display: flex;
      justify-content: center;
      align-items: center;`
  document.body.appendChild(el)
  // 要把对应和销毁方法返回出去，这样别人才能使用
  return [el, () => el.remove()]
}

class Child extends Component {
  el = createDialog()
  componentDidMount() {
    this.timer = setTimeout(this.el[1], 3000)
  }

  componentWillUnmount() {
    this.el[1]()
    // 卸载组件前清除计时器，防止组件意外卸载，导致setTimeout中的代码报错
    this.timer && clearTimeout(this.timer)
  }

  render() {
    return createPortal(
      <div>
        <h3>我是弹层@</h3>
      </div>,
      this.el[0]
    )
  }
}

export default Child
```

