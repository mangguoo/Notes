## 组件的key属性

> react中的key属性，它是一个特殊的属性，它是出现不是给开发者用的，而是给React自己使用，有了key属性后，就可以与组件建立了一种对应关系，react利用key来识别组件，他是一种身份标识。每个key 对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。在render函数执行的时候，新旧两个虚拟DOM会进行对比，如果两个元素有不同的key，那么在前后两次渲染中就会被认为是不同的元素，这时候旧的那个元素会被销毁，新的元素会被创建。如果提供了唯一的标识key且是相同的key，且元素类型相同， 若元素属性有所变化，则React只更新组件对应的属性，这种情况下，性能开销会相对较小。

利用这个特性，我们就可以强制重新渲染某个组件，原理就是给组件传入一个与上次不同的key，下面这个组件用于显示一个食品列表，列表到达底部时就会调用父组件传给他的loadData方法，在这个方法中会加载新的数据，然后通过data再传给他，从而触发他的更新，但是如果不想让他更新，而是让他重新渲染，就可以每次给他一个不同的Key，比如说页码，这样就会触发他的重新创建。

```jsx
<GoodFood 
  key={'goodfood_' + this.state.page} 
  data={this.state.goodfood} 
  loadData={this.loadData} 
/>
```

## 组件懒加载

### Suspense

> Suspense 的中文意思是悬而不定，顾名思义指的是数据加载完成之前页面呈现的内容。
> 在 Suspense 内的任何子组件（数据）只要还在 pending 或者初始状态，则显示的是 fallback 的内容。等所有的数据加载完成才显示子组件，避免多次更新。

### lazy

> 我们都知道使用 webpack 打包后会将所有的资源打包到一个入口文件中，这样可以减少请求的资源数量。
>
> 当然我们可以使用 mini-css-extract-plugin 插件将 CSS 单独分割出来。但是所有的项目打包到一个 js 文件难免造成体积过大加载缓慢的情况。
>
> 使用 React.lazy 可以将组件打包到单独的 chunk 文件中，并且实现按需加载。比如在加载首页时只加载首页所需要的资源文件，这样就可以提升加载速度。
>
> React.lazy 是一个函数。它接收一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件，因此刚好可以和 import() 完美配合。

### 案例展示

```jsx
import React, { lazy, Suspense, Fragment } from "react";
import { Switch, Route } from "react-router-dom";
import Admin from "@/views/Admin";

const Login = lazy(() => import(/* webpackChunkName: 'login' */ "@/views/Login"));

const RouterView = () => {
  return (
    <Fragment>
      <Suspense fallback={<h3>加载中...</h3>}>
        <Switch>
          <Route path="/login" component={Login} />
          <Route path="/" component={Admin} />
        </Switch>
      </Suspense>
    </Fragment>
  );
};

export default RouterView;
```

## esModuleInterop标识

### 问题引入

> JS 引入 react 是这样的：
>
> ```js
> import React from 'react'
> ```
>
> 而 TS 却是这样的：
>
> ```ts
> import * as React from 'react'
> ```
>
> 如果直接在 TS 里改成 JS 一样的写法，在安装了 @types/react 的情况下，编辑器会抛出一个错误，根据提示，在 tsconfig.json 中设置 compilerOptions.esModuleInterop 为 true，报错就消失了。

要搞清楚这个问题的原因，首先需要知道 JS 的模块系统。常用的 JS 的模块系统有三个：

- CommonJS（后文简称 cjs）
- ES module（后文简称 esm）
- UMD

- AMD （现在用得比较少了，可以忽略掉）

babel、TS 等编译器更加偏爱 cjs。默认情况下，代码里写的 esm 都会被 babel、TS 转成 cjs。这个原因我推测有以下几点：

1. cjs 出现得比 esm 更早，所以已有大量的 npm 库是基于 cjs 的（数量远高于 esm），比如 react
2. cjs 有着非常成熟、流行、使用率高的 runtime：Node.js，而 esm 的 runtime 目前支持非常有限（浏览器端需要高级浏览器，node 需要一些稀奇古怪的配置和修改文件后缀名）
3. 有很多 npm 库是基于 UMD 的，UMD 兼容 cjs，但因为 esm 是静态的，UMD 无法兼容 esm

打开 react 库的 index.js，：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/v2-13b243bb852d872316ef4f2d7fd73e51_720w.webp" alt="v2-13b243bb852d872316ef4f2d7fd73e51_720w" style="zoom: 67%;" />

可以看到 react 是基于 cjs的，相当于：

```js
module.exports = {
  Children: Children,
  Component: Component
}
```

而在 index.ts 中，写一段：

```js
import React from "react";
console.log(React);
```

默认情况下，经过 tsc 编译后的代码为：

```js
"use strict";
exports.__esModule = true;
var react_1 = require("react");
console.log(react_1["default"]);
```

显然，打印出来的结果为 undefined，因为 react 的 module.exports 中根本就没有 default 和这个属性。所以后续获取 React.createElement、React.Component 自然都会报错。

这个问题引申出来的问题其实是，目前已有的大量的第三方库大多都是用 UMD / cjs 写的（或者说，使用的是他们编译之后的产物，而编译之后的产物一般都为 cjs），但现在前端代码基本上都是用 esm 来写，所以 esm 与 cjs 需要一套规则来兼容。

- esm 导入 esm

- - 两边都会被转为 cjs
  - 严格按照 esm 的标准写，一般不会出现问题

- **esm 导入 cjs**

- - 引用第三方库时最常见，比如 react
  - **兼容问题的产生是因为 esm 有 default 这个概念，而 cjs 没有。任何导出的变量在 cjs 看来都是 module.exports 这个对象上的属性，esm 的 default 导出也只是 cjs 上的 module.exports.default 属性而已**
  - 导入方 esm 会被转为 cjs

- cjs 导入 esm （一般不会这样使用）

- cjs 导入 cjs

- - 不会被编译器处理
  - 严格按照 cjs 的标准写，不会出现问题

### TS 默认编译规则

> TS 对于 import 变量的转译规则为：

```js
// 对于 import 导入默认导出的模块，TS 在读这个模块的时候会去读取上面的 default 属性 
import React from 'react'; // before
console.log(React)
var React = require('react'); // after
console.log(React['default'])

// 对于 import 导入非默认导出的变量，TS 会去读这个模块上面对应的属性
import {Component} from 'react'; // before
console.log(Component);
var React = require('react'); // after
console.log(React.Component)
 
// 对于 import *，TS 会直接读该模块
import * as React from 'react'; // before 
console.log(React);
var React = require('react'); // after
console.log(React);
```

> TS、babel 对 export 变量的转译规则为：（代码经过简化）

```js
// 对于 export default 的变量，TS 会将其放在 module.exports 的 default 属性上
// 对于 export 的变量，TS 会将其放在 module.exports 对应变量名的属性上
export const name = "esm";  // before
export default {
   name: "esm default",
};

// 额外给 module.exports 增加一个 __esModule: true 的属性，用来告诉编译器，这本来是一个 esm 模块
exports.__esModule = true;  // after
exports.name = "esm";
exports["default"] = {
   name: "esm default"
}
```

### TS 开启 esModuleInterop 后的编译规则

> esModuleInterop 这个属性默认为 false。改成 true 之后，TS 对于 import 的转译规则会发生一些变化（export 的规则不会变）：

```js
 // before
 import React from 'react';
 console.log(React);
 // after（代码经过简化）
 var react = __importDefault(require('react'));
 console.log(react['default']);

 // before
 import {Component} from 'react';
 console.log(Component);
 // after（代码经过简化）
 var react = require('react');
 console.log(react.Component);
 
 // before
 import * as React from 'react';
 console.log(React);
 // after（代码经过简化）
 var react = _importStar(require('react'));
 console.log(react);
```

可以看到，对于默认导入和 namespace（*）导入，TS 使用了两个 helper 函数来帮忙（代码经过简化）

```js
// 如果目标模块是 esm，就直接返回目标模块；否则将目标模块挂在一个对象的 defalut 上，返回该对象
var __importDefault = function (mod) {
  return mod && mod.__esModule ? mod : { default: mod };
};

// 如果目标模块是 esm，就直接返回目标模块。否则将目标模块上所有的导出属性（除了default）挪到 result 上，最后将目标模块自己挂到 result.default 上
var __importStar = function (mod) {
  if (mod && mod.__esModule) {
    return mod;
  }

  var result = {};
  for (var k in mod) {
    if (k !== "default" && mod.hasOwnProperty(k)) {
      result[k] = mod[k]
    }
  }
  result["default"] = mod;

  return result;
};
```

### babel 的规则

> babel 默认的转译规则和 TS 开启 esModuleInterop 的情况差不多，也是通过两个 helper 函数来处理的。
>
> 因此js代码编译完是不会出错的，而ts代码不是通过babel或webpack来直接编译的，而是通过tsc来编译，因此就会出错。

![v2-6690177ecc0fedc4464ed2dfa26ccac1_720w](https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/v2-6690177ecc0fedc4464ed2dfa26ccac1_720w.webp)

_interopRequireDefault 类似 __importDefault

_interopRequireWildcard 类似 __importStar

### webpack 的规则

一般开发中，babel 和 TS 都会配合 webpack 来使用。而 TS 和 webpack 的结合有两种方式：

- ts-loader
- @babel/preset-typescript

如果是使用 ts-loader，那么 webpack 会将源代码先交给 tsc 来编译，然后处理编译后的代码。经过 tsc 编译后，所有的模块都会变成 cjs，所以 babel 也不会处理，直接交给 webpack 来以 cjs 的方式处理模块。

如果是使用的 @babel/preset-typescript，那么 webpack 不会调用 tsc，tsconfig.json 也会被忽略掉。而是直接用 babel 去编译 ts 文件。这个编译过程相比调用 tsc 会轻量许多，因为 babel 只会简单的移除所有 ts 相关的代码，不会做类型检查。一般在这种情况下，一个 ts 模块经过 babel 的 @babel/preset-env 和 @babel/preset-typescript 两个 preset 处理。后者做的事情很简单，仅仅去掉所有 ts 相关的代码，不会处理模块，而前者会将 esm 转成 cjs。然而 webpack 的 babel-loader 在调用 babel.transform 时，传了这样一个 caller 选项：

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/v2-e39beaecaf6d6a343efc1b1fa7c5c64e_720w.webp" alt="img" style="zoom: 67%;" />

从而导致 babel 保留了 esm 的 import export，这是因为 webpack 自己有一套模块机制，用来处理 cjs esm AMD UMD 等各种各样的模块。webpack 希望自己直接来处理用户写的模块，而不是让 babel 处理一遍再交给自己处理一遍。

对于 cjs 引用 esm，webpack 的编译机制比较特别（代码经过简化）：

```js
// before
import cjs from "./cjs";
console.log(cjs);
// after
var cjs = __webpack_require__("./src/cjs.js");
var cjsdefault = __webpack_require__.n(cjs);
console.log(cjsdefault.a);

// before
import esm from "./esm";
console.log(esm);
// after
var esm = __webpack_require__("./src/esm.js");
console.log(esm["default"]);
```

其中\_webpack_require__ 类似于 require，返回目标模块的 module.exports 对象。\_webpack_require__.n 这个函数接收一个参数对象，返回一个对象，该返回对象的 a 属性（我也不知道为什么属性名叫 a）会被设为参数对象。所以上面源代码的 console.log(cjs) 会打印出 cjs.js 的 module.exports

由于 webpack 为模块提供了一个 runtime，所以 webpack 处理模块对于 webpack 自己而言很自由，在模块闭包里注入代表 module require exports 的变量就可以了

### 总结

> 目前很多常用的包是基于 cjs / UMD 开发的，而写前端代码一般是写 esm，所以常见的场景是 esm 导入 cjs 的库。但是由于 esm 和 cjs 存在概念上的差异，最大的差异点在于 esm 有 default 的概念而 cjs 没有，所以在 default 上会出问题。TS babel webpack 都有自己的一套处理机制来处理这个兼容问题，核心思想基本都是通过 default 属性的增添和读取。

## React Hooks心智模型

> $React Hooks 心智模型：必须按顺序、不能在条件语句中调用的规则$
>
> react hooks有一个限制，不要在循环，条件或嵌套函数中调用 Hook，确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 `useState` 和 `useEffect` 调用之间保持 hook 状态的正确

### useState的工作原理

> useState hook背后的思想是，你可以使用 hook 函数返回的数组的第二个数组项作为 setter 函数，并且该 setter 将控制由 hook 管理的状态。下面以一个例子来理解useState：

```jsx
function RenderFunctionComponent() {
    const [firstName, setFirstName] = useState("Rudi");
    const [lastName, setLastName] = useState("Yardley");
 
    return (
        <Button onClick={() => setFirstName("Fred")}>Fred</Button>
    );
}
```

#### useState的具体实现

- **初始化：**创建两个空数组：`setters` 和 `state`，并将 cursor 设置为 0

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111013758-191510416.png" alt="img" style="zoom: 67%;" />

- **第一次渲染：**首次运行组件函数，每次useState()调用，在第一次运行时，都会将一个 setter 函数推送到 setters 数组上，然后将一些状态推送到 state 数组上

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111040565-1891855337.png" alt="img" style="zoom:67%;" />

- **后续渲染：**每次后续渲染都会重置 cursor，并且仅从每个数组中读取这些值

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111057882-1329150053.png" alt="img" style="zoom:67%;" />

- **事件处理：**每个 setter 都有对其 cursor 的引用，因此通过触发对 setter 的调用，setter 它将更改状态数组中该位置的状态值

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111131036-1171682237.png" alt="img" style="zoom:67%;" />

#### 简单代码实现

```jsx
const state = [];
const setters = [];
let cursor = 0;
 
function createSetter(cursor) {
    return function setterWithCursor(newVal) {
        state[cursor] = newVal;
    };
}
 
export function useState(initVal) {
    if (state[cursor] === undefined && setters[cursor] === undefined) {
        state.push(initVal);
        setters.push(createSetter(cursor));
    }
 
    const setter = setters[cursor];
    const value = state[cursor];
 
    cursor++;
    return [value, setter];
}
 
function RenderFunctionComponent() {
    const [firstName, setFirstName] = useState('Rudi'); // cursor: 0
    const [lastName, setLastName] = useState('Yardley'); // cursor: 1
 
    return (
        <div>
            <button onClick={() => setFirstName('Richard')}>Richard</button>
            <button onClick={() => setLastName('Fred')}>Fred</button>
        </div>
    );
}
 
function MyComponent() {
    cursor = 0; // resetting the cursor
    return <RenderFunctionComponent />; // render
}
 
console.log(state); // Pre-render: []
MyComponent();
console.log(state); // First-render: ['Rudi', 'Yardley']
MyComponent();
console.log(state); // Subsequent-render: ['Rudi', 'Yardley']
 
// click the 'Richard' button
console.log(state); // After-click: ['Richard', 'Yardley']
```

### 为什么顺序很重要

> 现在，如果我们根据某些外部因素甚至组件状态更改渲染周期的钩子顺序会发生什么？

```jsx
let firstRender = true;
 
function RenderFunctionComponent() {
  let initName;
 
  if(firstRender){
    [initName] = useState("Rudi");
    firstRender = false;
  }
  const [firstName, setFirstName] = useState(initName);
  const [lastName, setLastName] = useState("Yardley");
 
  return (
    <Button onClick={() => setFirstName("Fred")}>Fred</Button>
  );
}
```

- **Bad Component第一次渲染**

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111310884-1555363583.png" alt="img" style="zoom:67%;" />

- **Bad Component第二次渲染：**`firstName`和`lastName`发生了错位，我们的状态存储变得不一致了。这就是为什么保持正确顺序的重要性

<img src="https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/532971-20210729111330977-325690002.png" alt="img" style="zoom:67%;" />

## 闭包陷阱

### useState的闭包陷阱

> 在函数组件中，如果我们在回调函数中使用了 state 的值，那么闭包就会产生。闭包在函数创建时产生，他会缓存创建时的 state 的值

```jsx
import React, { useState } from "react";
const LikeButton: React.FC = () => {
  const [like, setLike] = useState(0);
  function handleAlertClick() {
    setTimeout(() => {
      alert(`you clicked on ${like}`);
      //形成闭包，所以弹出来的是当时触发函数时的like值
    }, 3000);
  }
  return (
    <>
      <button onClick={() => setLike(like + 1)}>{like}赞</button>
      <button onClick={handleAlertClick}>Alert</button>
    </>
  );
};
export default LikeButton;
```

在like为6的时候, 点击 alert , 再继续增加like到10, 弹出的值为 6, 而非 10。当我们更改状态的时候，React会重新渲染组件，每次的渲染都会拿到独立的like值，并重新定义个handleAlertClick函数，每个handleAlertClick函数体里的like值也是它自己的，所以当like为6时，点击alert，触发了handleAlertClick，此时的like是6，哪怕后面继续更改like到10，但alert时的like已经定下来了

![7de34cc101cdde7088a15dec436d7659](https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/7de34cc101cdde7088a15dec436d7659.gif)

#### 解决方法

- **采用全局变量：**

```jsx
import React from "react";
let like = 0;
const LikeButton: React.FC = () => {
  function handleAlertClick() {
    setTimeout(() => {
      alert(`you clicked on ${like}`);
    }, 3000);
  }
  return (
    <>
      <button
        onClick={() => {
          like = ++like;
        }}
      >
        {like}赞
      </button>
      <button onClick={handleAlertClick}>Alert</button>
    </>
  );
};
export default LikeButton;
```

由于like变量是定义在组件外，所以不同渲染间是可以共用该变量,所以3秒后获取的like值就是最新的like值。但是改变like并不会触发组件重新渲染，因此看起来like一直是0

![c8706c7482867dde33f0bb23ce4695b3](https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/c8706c7482867dde33f0bb23ce4695b3.gif)

- **使用useRef：**

```jsx
import React, { useRef } from "react";
const LikeButton: React.FC = () => {
  // 定义一个实例变量
  let like = useRef(0);
  function handleAlertClick() {
    setTimeout(() => {
      alert(`you clicked on ${like.current}`);
    }, 3000);
  }
  return (
    <>
      <button
        onClick={() => {
          like.current = like.current + 1;
        }}
      >
        {like.current}赞
      </button>
      <button onClick={handleAlertClick}>Alert</button>
    </>
  );
};
export default LikeButton;
```

采用useRef,作为组件实例的变量，保证获取到的数据肯定是最新的。但是useRef中current更改并不会触发re-render。但是 useRef 是定义在实例基础上的，如果代码中有多个相同的组件，每个组件的 ref 只跟组件本身有关，跟其他组件的 ref 没有关系

![c8706c7482867dde33f0bb23ce4695b3](https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/c8706c7482867dde33f0bb23ce4695b3.gif)

### useEffect的闭包陷阱

```jsx
import { useEffect, useState } from 'react';

const App = () => {
    const [count,setCount] = useState(0);

    useEffect(() => {
        setInterval(() => {
            setCount(count + 1);
        }, 500);
    }, []);

    useEffect(() => {
        setInterval(() => {
            console.log(count);
        }, 500);
    }, []);

    return <div>count: {count}</div>;
}

export default App;
```

上面组件的打印结果一直是1。这是因为useEffect的第二个参数为空数组，所以只会在组件加载后仅执行一次，我们知道组件每次render的时候都会生成一个新的state对象，对应一个快照，上述代码中，因为useEffect只执行了一次，所以定时器中的`count`一直是最初快照里的`count`，那么页面中`count`的显示肯定不会改变。闭包陷阱产生的原因其实就是 useEffect 的函数里引用了某个 state，形成了闭包。

#### 解决方法

- **解法一：**

> 使用useEffect的第二个参数，count变化时，重新执行`setInterval`，并且在useEffect的清理函数中执行`clearInterval`，这样我们就可以在页面上看到变化的count了

```jsx
import { useEffect, useState } from 'react';

const App = () => {
    const [count,setCount] = useState(0);

    useEffect(() => {
      const timer = setInterval(() => {
        setCount(count + 1);
      }, 1000);
      return () => clearInterval(timer)
    }, [count]);

    useEffect(() => {
      const timer = setInterval(() => {
        console.log(count);
      }, 1000);
      return () => clearInterval(timer)
    }, [count]);

    return <div>count: {count}</div>;
}

export default App;
```

但是这种方法有一定的缺点，因为每次count变了都要重置定制器，这样可能会导致计时不准确。所以这种把依赖的 state 添加到 deps 里的方式是能解决闭包陷阱，但是定时器不能这样做

- **解法二：**

> 最主要的是`setCount(count => count +1)`，使用函数作为参数，接受一个旧的state，得到新的state
> 使用`useRef`来保存回调函数，在`useEffect`中从 `ref.current` 来取函数再调用，在`useLayoutEffect`中给`ref`赋值新的fn，这个fn里的state是最新的

```jsx
import { useEffect, useLayoutEffect, useRef } from "react";

const App = () => {
  const [count, setCount] = useState(0);

  const fn = () => {
    console.log(count);
  };

  const ref = useRef(() => {});

  useEffect(() => {
    // 最关键的一步，使用函数，接受一个旧的state，得到新的state
    setInterval(() => {
      setCount((count) => count + 1);
    }, 1000);
  }, []);

  // 每次在render前都给ref赋值新的fn，这个fn里的state是最新值
  // 这里是利用了useLayoutEffect在useEffect之前执行的特性
  useLayoutEffect(() => {
    ref.current = fn;
  });

  useEffect(() => {
    // 如果直接使用fn的话，那相当于一直使用同一个闭包，这个闭包中的count是固定的，一直是第一次创建时赋值的0，所有需要每次更新时执行新的函数
    setInterval(() => ref.current(), 1000);
  }, []);

  return <div>count: {count}</div>;
};

export default App;
```

**以上这个代码可以封装成`useInterval`(自定义hook)：**

```js
import { useEffect, useLayoutEffect, useRef } from 'react';

const useInterval = (fn: Function, delay: number)=>{
    const ref = useRef<Function>(()=>{})

    useLayoutEffect(()=>{
        ref.current = fn
    })

    useEffect(()=>{
        setInterval(()=>{
            ref.current()
        }, delay)
    }, [])
}

export default useInterval
```

```js
import useInterval from './useInterval';

const App = () => {
    const [count,setCount] = useState(0);
    useInterval(()=>{
        setCount(count => count+1)
    }, 1000)
    useInterval(()=>{
        console.log(count, 'count')
    }, 1000)
    
    return <div>count: {count}</div>;
}

export default App;
```

#### 扩展知识

- 使用`useEffect`时，若有多个副作用，则应该调用多个`useEffect`，而不是写在一个里面
- `useEffect`第一个参数可以返回一个函数，这个函数会在组件卸载时（也就是render了，生成新的快照时）执行，可以用来清除副作用里的操作
- `useLayoutEffect`是在render前同步执行的（和`componentDidMount`等价），`useEffect`是在render后异步执行的

## React18的useEffect会执行两次

> 这是 React18 才新增的特性。它仅在开发模式("development")下，且使用了严格模式("Strict Mode")下会触发。生产环境("production")模式下和原来一样，仅执行一次
> react之所以要把useEffect的回调执行两次，是因为react其实是在组件挂载后，还 "额外"模拟执行了一次组件的卸载和挂载。这样可以帮助开发者提前发现重复挂载造成的 Bug 的代码
> 同时，这也是为了以后 React的新功能做铺垫。未来会给 React 增加一个特性，允许 React 在保留状态的同时，能够做到仅仅对UI部分的添加和删除。为了让开发者能够提前习惯和适应，做到组件的卸载和重新挂载之后，重复执行 useEffect 的时候不会影响应用正常运行

### 如何应对

> 对于这个问题，官方文档上面有一句原话：正确的问题不是“怎么样让 Effect 执行一次”，而是“怎样修复我的 Effect，让它在(重复)挂载之后正常工作”
>
> 毕竟在 React 的未来版本中做离屏渲染的时候 useEffect 肯定会多次执行的。而且，即使是当前版本，在做页面的前进后退也会面临触发多次 useEffect。所以，解决办法其实就是重复挂载卸载之后使得应用能够正常工作

每次组件渲染时，React 都会更新页面 UI，然后运行 useEffect 中的代码，Effect 在屏幕更新之后的 rendering 进程结束的时候执行。因此，对于某些“副作用”的渲染，比如异步接口请求，事件绑定等操作我们通常都放在 useEffect 中执行

useEffect 支持返回一个函数，在组件卸载的时候就会执行该函数。因此正确解法就是在useEffect返回的函数中实现清理副作用

- **清理事件监听**

```js
useEffect(() => {
  function handleScroll(e) {
    console.log(e.clientX, e.clientY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

- **重置页面数据**

```js
// 清除属性状态：对于一些页面属性的变更，在返回函数内部将其变更的属性进行还原
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);
```

```jsx
// 涉及到元素状态的，比如播放器之类，需要对（元素）播放器的状态进行重置
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

```js
// 如果是默认弹窗类，这种也算是元素状态，同样需要对其（弹出）状态进行重置
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

- **处理异步数据请求**

在useEffect中进行异步请求时，由于react会在开发环境中额外模拟一次组件的卸载和重新挂载，因此第一次异步执行网络请求时，组件其实已经卸载了，再通过网络请求的数据进行更改组件状态是会报错的

因此这里在返回函数中把ignore设为true，这样第一次执行的时候就不会执行setTodos(json)了，它其实是在第二次执行的时候才会触发

并且这里使用useRef对网络请求到的数据进行了缓存，下次请求的时候如果已经有缓存数据了就直接用，无须再次发起请求

```js
const cache = useRef(null);
useEffect(() => {
  let ignore = false;
  async function startFetching() {
    if (!cache.current) {
      cache.current = await fetchTodos(userId);
    }
    if (!ignore) {
      setTodos(cache.current);
    }
  }
  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```



