### 生命周期

![component](https://cdn.jsdelivr.net/gh/ilmangoi/imgRepo@main/img/component.png)

#### constructor

> React组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要先在添加其它内容前，调用super(props)，用来将父组件传来的props绑定到继承类中。它只会被调用一次

```js
constructor(props) {
    super(props)
}
```

#### render

> render()方法是必需的，它主要负责组件的渲染，会被重复调用若干次

#### getDerivedStateFromProps

> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应该返回一个对象来更新 state，如果返回 null 则不更新任何内容。此方法适用于罕见的用例，即当前组件的 state 的值在任何时候都取决于 props传入。
>
> - 此方法它是一个静态方法，静态方法中不能使用this
> - 此方法必须要有返回值，{}|null  , 使用此方法一定要先定义好state，否则报错
> - 如果返回为对象，则会对state中数据进行操作，对象属性如果在state中没有则添加，有则修改
> - 如果返回为null,则不会对state进行任何操作
> - 该生命周期会接收两个参数，nextProps和nextState，因为该生命周期函数是一个静态方法，因为它的this不是指向组件实例的，因此需要使用这两个参数来获取参数和状态。 
>   - nextProps: 当前最新的props数据
>   - nextState: 当前最新的state数据,暂时不包含你返回值中要对state修改的值

```jsx
import React, { Component } from "react";

class Child extends Component {
  constructor(props) {
    super(props);
    this.state = { name: "张三", age: 1 };
  }

  // 如果想用此方法把props中的属性数据追加到state中,后续能修改,则这样的操作要确保只会执行1次，因为如果让他每次更新都合并参数的话，会导致组件一更新就会合并一次，这样就导致参数值永远是父组件传进来的初始值
  static getDerivedStateFromProps(nextProps, nextState) {
    if (nextState.age === 1) {
      return nextProps;
    }
    return null;
  }

  render() {
    let { age } = this.state;
    return (
      <div>
        <h3>{age}</h3>
        <button
          onClick={() => {
            this.setState((state) => ({ age: state.age + 1 }));
          }}
        >
          ++++
        </button>
      </div>
    );
  }
}

class App extends Component {
  constructor(props) {
    super(props);
    this.state = { age: 10 };
  }

  render() {
    let { age } = this.state;
    return (
      <div>
        <Child age={age} />
      </div>
    );
  }
}

export default App;
```

#### componentDidMount

> 它会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。

#### getSnapshotBeforeUpdate

> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息，此生命周期的任何返回值将作为参数传递给 componentDidUpdate()

#### componentDidUpdate

> 会在数据更新后会被立即调用。首次渲染不会执行此方法。
>
> - prevProps 修改之前的props数据
> - prevState 修改之前的state数据
> - 此方法要有一个返回值，且如果有此方法，则必须要有componentDidUpdate
> - 此方法的返回值，会在componentDidUpdate参数3中接受

```js
getSnapshotBeforeUpdate(prevProps, prevState) {
    console.log('child --- getSnapshotBeforeUpdate')
    return 100
}

componentDidUpdate(prevProps, prevState, snapshot) {
    console.log('child --- getSnapshotBeforeUpdate', snapshot)
}
```

#### componentWillUnmount

> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作

#### shouldComponentUpdate

> 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true则组件继续渲染，为false则当前组件不会渲染。首次渲染或使用 forceUpdate() 时不会调用该方法。此方法仅作为性能优化的方式而存在。
>
> 也可以考虑使用内置的 **PureComponent** 组件，而不是手动编写 shouldComponentUpdate()。**PureComponent** 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。

当**this.setState()**修改了state中的数据后，当前组件将重新渲染，同时也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件），这就会导致一个问题，就算传给子组件的值没有发生改变，子组件也会被更新，这就造成了极大的性能浪费。

**使用PureComponent为解决：**

> 如果使用了PureComponent，它会判断传进来的参数有没有发生变化，如果没有变化，则跳过更新，但是这种判断只能针对基础数据类型，如果传递的参数是一个对象，它只会判断对象的引用地址发生了变化，这就会导致它的优化失效，因为使用setState改变引用类型一定会导致对象引用地址发生改变。`this.setState({ num: { data: 1 } })`

```jsx
import React, { Component, PureComponent } from 'react'

class Child extends PureComponent {
  render() {
    console.log('child -- render')
    return (
      <div>
        <h3>{this.props.name}</h3>
      </div>
    )
  }
}

class App extends Component {
  state = {
    num: { data: 1 },
    name: '张三'
  }
  render() {
    console.log('app -- render')
    return (
      <div>
        <h3>{this.state.num.data}</h3>
        <Child name={this.state.num} />
        <button onClick={() => this.setState({ num: { data: 1 } })}>++num++</button>
      </div>
    )
  }
}

export default App
```

**使用shouldComponentUpdate生命周期解决：**

> - 此方法必须要有一个boolean返回值
> - 此方法只有在更新时才会触发
> - true 则继续向下渲染  render
> - false 表示当前不会继续渲染,从而减少无用渲染,提升性能
> - nextProps 最新的props数据   this.props 之前的props数据
> - nextState 最新的state数据   this.state 之前的state数据

```jsx
import React, { Component, PureComponent } from 'react'
import _ from 'lodash'

class Child extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    return !_.isEqual(this.props, nextProps)
  }
  render() {
    console.log('child -- render')
    return (
      <div>
        <h3>{this.props.num.data}</h3>
      </div>
    )
  }
}

class App extends Component {
  state = {
    num: { data: 1 },
    name: '张三'
  }
  render() {
    console.log('app -- render')
    return (
      <div>
        <h3>{this.state.num.data}</h3>
        <Child num={this.state.num} />
        <button onClick={() => this.setState({ num: { data: 1 } })}>++num++</button>
      </div>
    )
  }
}

export default App
```

