## 单例设计模式

> 实际开发中，外部访问某个类的对象【实例】时，确保只能访问该类的唯一对象时才能保证逻辑的正确性时，这时就应该使用单件设计模式。

### 定义单例

如果某个类对外始终只提供一个实例，并且在该类的内部提供了一个外部访问该对象的方法或该对象属性，那么这种编写代码方案就是单件设计模式。

### 应用场景

**应用场景1：**

比如 Vuex，React-Redux 中的全局状态管理容器 store 对象在整个项目被设计成唯一的实例，把 store 对象所在的类设计成单件设计模式将是最好的设计方案。

**应用场景2：**

一般前端项目需要进行客户端本地数据存储时，都会考虑使用 localStorage，因为只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份 localStorage 数据。那封装 localStorage设计成一个单件设计模式类就再合适过了。

**应用场景3：**

日志记录是一个项目中必不可少的环节，当我们为一个项目编写一个日志文件类，用来保存日志和阅读日志信息时，这个日志文件类可以有多种设计方案，但把类写成单件模式是最好的方案，因为每次存储日志信息到日志文件上时都创建一个日志对象，这既没有必要，也很浪费内存空间。

### 示例

> 构建单件设计模式：
>
> - 把构造器设置为私有的，不允许外部来创建类的实例【对象】
> - 至少应该提供一个外部访问的方法或属性，外部可以通过这个方法或属性来得到一个对象，所以应该把这个方法设置为静态方法
> - 外部调用第二步提供的静态方法来获取一个对象

```js

export default class MyLocalStorage {
  static localstorage: MyLocalStorage //静态引用属性
  private constructor() { }

  public static getInstance() {
    if (!this.localstorage) {
      this.localstorage = new MyLocalStorage()
    }
    return this.localstorage
  }

  public setItem(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value))
  }

  public getItem(key: string) {
    let value = localStorage.getItem(key)
    return value != null ? JSON.parse(value) : null;

  }
}
```

### 根据单例来掌握静态属性和方法

1. 可以通过类名直接调用静态成员，格式：类名.静态属性  类名.静态方法。

2. 在TS类的静态方法中可以直接使用 this 来获取静态成员。

3. 静态方法中不可以直接访问类中原型对象上的方法或对象属性，因为静态方法中的this指向类本身。

4. 对象变量也不可以直接访问静态成员。

5. 一个静态方法改变了某个静态属性，其他静态方法或类外部任何地方访问这个属性都会发生改变。	

6. 静态成员保存在内存哪里？何时分配的内存空间呢？

   答：任何一个 TS 类中的静态成员存储在内存的静态区，运行一个 TS 类，TS首先会为静态成员开辟内存空间，静态成员的内存空间分配的时间要早于对象空间的分配，也就是任何一个对象创建之前 TS 就已经为静态成员分配好了空间。但一个静态方法或静态属性只会分配一个空间，只要当前服务器不重启或控制台程序还没有结束之前【如果是开发期间临时测试，一般用控制台】，那么静态方法或者是静态属性就一直存在内存空间，无论调用多少次这个静态方法或静态属性，都是调用的同一块空间。

   也就是说无论你是否创建对象，创建多少个对象，是否调用该静态方法或静态属性，TS都会为这个静态方法或静态属性分配内存空间，注意：静态成员和对象无关。并且一旦为静态方法或静态属性分配好空间，就一直保存到内存中，直到服务器重启或者控制台程序执行结束才被释放。

7. 静态方法或属性和原型对象空间上的方法或属性有何区别？

   答：原型对象空间上的方法和属性用来提供给该类的所有对象变量共用的方法或属性，没有对象和对象变量，原型上的属性和方法就没有了用武之地，而静态方法或静态属性属于类，可以通过类来直接访问。任何一个对象创建之前 TS 就已经为静态成员分配好了空间。但一个静态方法或静态属性只会分配一个空间，而每一个对象都有自己独立的空间。

8. 静态方法是否可以接受一个对象变量来作为方法的参数？

   答：可以，静态方法内部不能通过this来访问对象属性和方法，但可以通过调用静态方法时把对象变量传递给静态方法来使用。比如：我们把 js 的 Object 构造函数想象成一个 TS 类【实际 TS 类编译后的 JS 文件中就变成了一个构造函数】。Object 类就拥有大量的静态方法，例如：keys，values，entries等，现在我们来关注静态方法是否可以接受对象变量作为方法的参数，我们以Object.keys方法为例 【Object类的keys方法用来获取给定对象的自身可枚举属性组成的数组】。

9. 何时应该把一个方法定义成静态方法或属性定义为静态属性呢？

   - 应用1：单件设计模式就是静态方法和静态属性很好的应用场景之一。当外部不能创建对象，就只能借助类内部的静态方法来获取类的对象；这时肯定不能把这个方法定义成原型对象属性上的方法，只能定义为类的静态方法，因为如果定义成原型对象属性的方法，就会导致外部无法被访问，因为外部根本不能创建对象，也就无法访问原型对象属性上的方法。而静态方法要访问的属性就只能是静态属性了，这也是静态属性的应用时机。

   - 应用2：当类中某个方法没有任何必要使用任何对象属性时，而且使用了对象属性反而让这个方法的逻辑不正确，那既如此，就应该禁止这个方法访问任何对象属性和其他的对象方法，这时就应该把这个方法定义为静态方法。例如：一个顾客类的购买方法中肯定要允许访问顾客姓名或其他顾客微信这些对象属性，这样的方法我们就需要定义在原型对象属性上，但如果顾客类中的阅读顾客积分公告方法是针对全体顾客的公告方法，就应该定义为静态方法，方法内部就应该禁止出现任何具体的对象属性。如果在这样的方法中使用了顾客的某个属性，比如用了顾客姓名，那么这个方法逻辑就不正确。所以我们应该让这样的方法禁止访问对象属性和其他的对象方法，那就应该设置为静态方法。

   - 应用3：当一个类中某个方法只有一个或者 1-2个对象属性，而且更重要的是，你创建这个类的对象毫无意义，我们只需要使用这个类的一个或者多方法就可以了，那么这个方法就应该定义为静态方法。常见的工具类中的方法通常都应该定义为静态方法。比如 utils 工具函数。

     ```js
     class FileUtil{
        // 从指定文件上把数据读出来打印在控制台或页面上的静态方法
        public static readFile(readonly fileName:string) {  
           fs.readFile(fileName, (err: any, data: any) => {
               console.log("fs.readFile:", data.toString());
           })
        }
        // 把键盘输入的数据或页面上获取的数据写入到指定文件上的静态方法
        public static writeFile(fileName:string) {
            fs.writeFile(fileName, '刘老根4', function (error) {
               if (error) console.log('写文件失败')
               else console.log('写文件成功')
     	   })
        }
     }
     // 实际应用中，读和写一般都不在一个时间段，可能读功能完成后，过了几分钟，用户才在客户端执行写的方法，
     // 又过了一会，用户又在客户端执行了读的方法。 但我们知道静态方法实际上是一直保存到内存空间，这样反复
     // 操作其实节省了大量反复创建 和释放 FileUtil 对象的时间和对应的对象内存空间。
     FileUtil.readFile('./log.txt')
     FileUtil.writeFile('./log5.txt')
     ```

### 彩蛋：

new 一个 TS 类的方法可以吗？能在TS 类外部使用 prototype为TS类增加方法或属性吗?

> 虽然在 JS 中可以 new 一个类【构造函数】内部定义的对象方法或静态方法，但TS已经屏蔽了去new 一个类中的方法【 JS 可以，会当成一个构造函数】。
>
> TS 类可以访问 prototype 原型对象属性，但无法在 prototype 原型对象属性增加新的方法或属性，这么做，就是让我们只能在类的内部定义方法，防止回到 ES5 从前非面向类和对象的而写法。【但是可以覆盖类上已经存在的方法】