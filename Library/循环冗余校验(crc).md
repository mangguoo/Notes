# 循环冗余校验（CRC）

## 使用CRC的目的

数据在传输时一般希望具有以下特性的一种或多种：

1. **机密性**，信息的内容不想被别人偷看；例如A给B写了一封信，担心信被别人拿到然后偷看了其中的内容，A可能会用某种加密方式（这种方式是和B约定好的）给信的内容加密，只有B能阅读信的内容。
2. **完整性**，信息不希望发生丢失；还是上面的例子，A给B写了一封信，担心信在邮寄过程中损坏，A可能会在信上做一些特殊的标记（这种方式是和B约定好的），然后B拿到信之后，通过检查标记就能知道信的内容是否完整。
3. **收发方鉴别**，能够确认信息是谁发过来的；还是上面的例子，A给B写了一封信，B能够通过信上的特定信息确定这封信是A写的。

CRC就是用于保证数据的**完整性。**

为了保证数据的“完整性”，前辈们发明的一种方法就是在要发送的数据后面加一个数，这个数是基于要发送的数据计算出来的值，通常称为校验和（checksum，这个词开始可能是描述通过sum方式计算出来的校验值，经过发展，现在是用于描述这个添加的校验值的通用术语），本文要讨论的CRC就是计算checksum的一种方法。在介绍CRC之前，我们先选一种简单的方法来计算checksum：将数据以字节为单位加起来，然后除以256，把余数作为checksum。

*注意checksum这种方式的本质：把原始数据的部分信息提取到checksum中，进而使得不同数据的checksum会有所区别*

```text
所有数据均为16进制
原始数据             ：1F C0 03 22
原始数据+校验和      ：1F C0 03 22 04
接收方收到的数据     ：1F C0 83 22 04
```

从上面的数据我们可以观察：

1) checksum是如何计算的
2) 接收方如何利用checksum判断报文发生了变动

发送报文的校验和是0x4（0x1F+0xC0+0x03+0x22=0x104，转换为10进制是260，除以256的余数就是4），数据在发送过程中可能受到了外部干扰，导致数据变动，接收方收到数据之后，重新计算校验和，发现应该是0x84（0x1F+0xC0+0x83+0x22=0x184，除以256的余数就是0x84），这样接收方就知道数据在传送过程中发生了变动，然后接收方可以决定是否要丢弃掉这条消息。

*这种方法看起来还不错，为什么还需要别的方法呢？*

因为采取这种方式时，不同数据的校验和容易重复，例如下面的一系列数据的校验和都是04，可以观察到这种校验方式无法区分数字相同，位置不同的情况

```text
原始数据+校验和      ：04 00 00 00 04
原始数据+校验和      ：00 00 04 00 04
原始数据+校验和      ：02 00 02 00 04
原始数据+校验和      ：00 01 00 03 04
```

再看看另外一个极端，既然checksum本质上是要提取原始数据的信息，然后还需要不同数据的checksum不会重复，那么直接把原始数据复制一份放在后面不就是完整保留了原始数据的信息吗？

```text
原始数据+校验和      ：01 FF 2C 00 01 FF 2C 00
```

相信大家很快看出来这种方式有什么问题，就是传输数据的效率太低，一条8个字节的报文中只有4个字节是有用的，剩余的只是用来保证数据的完整性。（磁盘数据备份中的RAID1就是用的这种完全备份的方式；看来不同的应用领域都有一些重要思想的应用，不同的设计也都有其应用场景）

在简单的计算方案和完全备份的方案之间，出现了很多中间方案，CRC，哈希（Hash）就是其中的两种，只不过CRC在汽车行业报文传输中用得比较多，哈希则在文件传输上用得比较多（下载文件的时候，有时会看到下载的地方提供了一个哈希值，就是让你检查下载完的文件是否也有相同的哈希值，哈希方法在很多地方都有应用，并不局限于此）

## 计算方法

### 模2运算

因为CRC的计算涉及到模2运算，所以先说一下模2运算，模2运算是一种二进制运算的方法，与四则运算类似，不同的是模2运算不考虑进位和借位。所以每一位的运算结果不会影响其他位。模2加法，模2减法和异或有同样的结果

```text
模2加法
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 0 (无进位)

模2减法
0 - 0 = 0
0 - 1 = 1 (无借位)
1 - 0 = 1
1 - 1 = 0

异或
0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0
```

下面看模2除法，初看的时候可能会比较疑惑，总体上与正常的除法是类似的，只不过在模2运算中数与数的大小关系与通常的理解不一致

![img](https://raw.githubusercontent.com/ilmangoi/imgRepo/main/img/v2-01026724658d21a1dc1095187ce894e8_720w.webp)

### CRC计算

计算CRC的例子:

- 原始数据是：1101011011

- 多项式： 1∗x4+0∗x3+0∗x2+1∗x1+1∗x0 （化简之后就是 x4+x1+x0 ）把多项式中各项的系数取出来依次排列构成除数：10011（至于为什么不直接用这个数字，而是有一个多项式，我不清楚）

- 把原始数据后面加4（上面多项式最高幂次为x^4）个0构成被除数：1101011011--0000（原始数据--填充位）

- 如下图所示为这个除法的计算过程（模2除法）

- 算出来的余数为1110，这就是checksum，增加了checksum的数据就是：1101011011--1110（原始数据--checksum）

![v2-3a80d8cf69d5ec454596e0490637c4e5_720w](https://raw.githubusercontent.com/ilmangoi/imgRepo/main/img/v2-3a80d8cf69d5ec454596e0490637c4e5_720w.webp)

### 常用的CRC计算方法

根据checksum的长度（单位是bit）不同，常用的有：

- CRC8，CRC16，CRC32的checksum长度分别占8位，16位，32位

根据使用的多项式或其他一些信息不同也会区分，例如：

- CRC16_CCIT_ZERO：使用的多项式是0x1021（指CRC校验的多项式的二进制码去掉最高位）

- CRC16_ARC：使用的多项式是0x8005